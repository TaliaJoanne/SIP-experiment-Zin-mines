---
title: "Zin SIP"
subtitle: "06 Differential abundance modelling using corncob"
author: "Roey Angel"
email: "roey.angel@bc.cas.cz"
date: "`r Sys.Date()`"
bibliography: references.bib
link-citations: yes
csl: fems-microbiology-ecology.csl
always_allow_html: true
output:
  rmarkdown::github_document:
    toc: true
    toc_depth: 5
    number_sections: false
    dev: "png"
    df_print: "kable"
    keep_html: true
---

```{r libraries, include=F, message=FALSE, warning = FALSE}
Sys.setenv(R_LIBS_USER = "~/R/library") # Uncomment if you have no write access to R path change to local library dir
.libPaths(c(Sys.getenv("R_LIBS_USER"), .libPaths())) # Uncomment if you have no write access to R path
library(extrafont) # Tools for using fonts, CRAN v0.17
library(tidyverse) # Easily Install and Load the 'Tidyverse', CRAN v1.3.0 
library(magrittr) # A Forward-Pipe Operator for R, CRAN v2.0.1 
library(scales) # Scale Functions for Visualization, CRAN v1.1.1 
library(RColorBrewer) # ColorBrewer Palettes, CRAN v1.1-2
library(svglite) # An 'SVG' Graphics Device, CRAN v1.2.3.2 
library(viridis) # Default Color Maps from 'matplotlib', CRAN v0.5.1
library(ggsci) # Scientific Journal and Sci-Fi Themed Color Palettes for 'ggplot2', CRAN v2.9
library(ggtext) # Improved Text Rendering Support for 'ggplot2', CRAN v0.1.1
library(kableExtra) # Construct Complex Table with 'kable' and Pipe Syntax, CRAN v1.3.1 
library(visdat) # Preliminary Visualisation of Data, CRAN v0.5.3
library(parallel) # Support for Parallel computation in R, CRAN v4.0.3
library(glue) # Interpreted String Literals, CRAN v1.4.2
library(patchwork) # The Composer of Plots, CRAN v1.1.1
library(vegan) # Community Ecology Package, CRAN v2.5-7
library(phyloseq) # Handling and analysis of high-throughput microbiome census data, Bioconductor v1.32.0 
library(speedyseq) # Faster implementations of phyloseq functions, [github::mikemc/speedyseq] v0.4.0 
library(Biostrings) # Efficient manipulation of biological strings, Bioconductor v2.56.0 
library(HTSSIP) # High Throughput Sequencing of Stable Isotope Probing Data Analysis, CRAN v1.4.1 
library(ggtree) # an R package for visualization of tree and annotation data, Bioconductor v2.2.4  # don't load here because of conflict with phyloseq
library(corncob) # Count Regression for Correlated Observations with the Beta-Binomial, [github::bryandmartin/corncob] v0.2.0
```

```{r style settings, echo=F, message=F, warning=F, results="asis", cache=T}
options(width = 90, knitr.table.format = "html") 
cache.path <- "06_Diff_abund_corncob_cache/"
fig.path <- "06_Diff_abund_corncob_figures/"
knitr::opts_chunk$set(
  warning = FALSE,
  message = FALSE,
  cache = TRUE,
  dev = "png",
  # dev = c("svglite", "png"),
  dev.args = list(png = list(bg = 'white')),
  # dev.args = list(svglite = list(bg = 'white'), png = list(bg = 'white')),
  dpi = 300,
  #  fig.width = 12,
  #  fig.height = 8,
  cache.path = cache.path,
  fig.path = fig.path
)
f_name <- "DejaVu Sans" #sub("\\s//", "", f_name)
f_size <- 12
font_import(pattern = "DejaVuSans\\.", prompt = FALSE)
loadfonts() # registers fonts
theme_set(theme_bw(base_size = f_size, base_family = f_name))
```

```{r functions, include=F}
#' gz
#' Compress a file using gz and delete the uncompressed file
#'
#' @param in_path (Required) Path and file name of a file to be compressed
#'
#' @param out_path (Required) Path and file name of the compressed file
#'
#' @author Roey Angel
#'
#' @return none
#'
#' @usage gz(paste0(file.path, ".svg"), paste0(file.path, ".svgz"))
#' @export

gz <- function(in_path, out_path = tempfile()) {
  out <- gzfile(out_path, "w")
  writeLines(readLines(in_path), out)
  close(out)

  file.remove(in_path)
  invisible(out_path)
}

#' Save a plot to svgz and png
#' The function uses `svglite` and `agg_png` devices and then comresses the svg to an svgz
#'
#' @param filename (Required) Path and file name excluding suffix (Default: "Rplot")
#'
#' @param plot (Required) Plot to save, defaults to last plot displayed
#'
#' @param scale (Optional) Multiplicative scaling factor (Default: 1)
#' 
#' @param pwidth, @param pheight (Optional) Plot size in "in" (Defaults: 10, 8)
#'
#' @param dpi (Optional) Plot resolution (Default: 300)
#'
#' @author Roey Angel
#'
#' @return none
#'
#' @usage save_figure(filename = "Rplot", 
#'                        plot = last_plot(), 
#'                        pwidth = 10, 
#'                        pheight = 8, 
#'                        dpi = 300, 
#'                        scale = 1, 
#'                        bg = "white",
#'                        pointsize = 12)
#' @export

save_figure <- function(filename = "Rplot", 
                        plot = last_plot(), 
                        pwidth = 10, 
                        pheight = 8, 
                        dpi = 300, 
                        scale = 1, 
                        bg = "white",
                        pointsize = 12) {
  require(svglite)
  require(ragg)
  
  svglite(paste0(filename, ".svg"), 
          width = pwidth, 
          height = pheight)
  print(plot)
  invisible(dev.off())
  
  agg_png(paste0(filename, ".png"),
          width = pwidth, 
          height = pheight, 
          units = "in",
          res = dpi, 
          scaling = scale)
  print(plot)
  invisible(invisible(dev.off()))
  
  gz(paste0(filename, ".svg"), paste0(filename, ".svgz"))
}

#' scale_libraries
#'
#' Scales libraries by:
#' 1) Taking proportions
#' 2) Multiplying by a given library size of n
#' 3) Rounding
#'
#' @param ps_obj (Required) A phyloseq object
#'
#' @param n (Optional) Library size to scale to (Default: min(sample_sums(physeq)))
#'
#' @param round (Optional) Rounding method. Either "floor" (default) or "round"
#'
#' @author https://github.com/DenefLab/MicrobeMiseq/blob/master/R/miseqR.R
#' @return A phyloseq objectn ordered data frame with the columns: ASV names, taxonomic rank names and abundance
#' @usage scale_libraries(Ps_obj, n = min(sample_sums(physeq)), round = "floor")
#' @export
#'
#'
scale_libraries <- function(physeq, n = min(sample_sums(physeq)), round = "floor") {
  require(phyloseq)

  # Transform counts to n
  physeq.scale <- transform_sample_counts(physeq,
    function(x) {(n * x/sum(x))}
  )

  # Pick the rounding functions
  if (round == "floor") {
    otu_table(physeq.scale) <- floor(otu_table(physeq.scale))
  } else if (round == "round") {
    otu_table(physeq.scale) <- round(otu_table(physeq.scale), digits = 0)
  }

  # Prune taxa and return new phyloseq object
  physeq.scale <- prune_taxa(taxa_sums(physeq.scale) > 0, physeq.scale)
  return(physeq.scale)
}

#' @title Replace zeros in OTU abundance
#'
#' @source <https://rdrr.io/github/vmikk/metagMisc/src/R/phyloseq_transform.R>
#' @param physeq A phyloseq-class object
#' @param method Which method to apply for zero replacement ("pseudocount")
#' @param pseudocount Constant value
#'
#' @return Phyloseq object with transformed counts in OTU table.
#' @export
#'
#' @examples
#'
phyloseq_replace_zero <- function(physeq, method = "pseudocount", pseudocount = 0.65){

  ## Extract OTU table
  tmp <- phyloseq::otu_table(physeq)

  ## Replace zeros with pseudocount
  if(method == "pseudocount"){
    tmp[ tmp == 0 ] <- pseudocount
  }

  ## Replace zeros with minimum observed OTU abundance
  if(method == "min"){
    trows <- taxa_are_rows(physeq)

    if(trows == TRUE){
      ## Find minimum non-zero abundances for each sample
      mins <- apply(X = tmp, MARGIN = 2, FUN = function(z){ z <- z[z > 0]; min(z) })

      ## Replace zeros with sample-specific count
      for(i in 1:ncol(tmp)){
        tmp[ tmp[, i] == 0, i ] <- mins[i]
      }
    }

    if(trows == FALSE){
      mins <- apply(X = tmp, MARGIN = 1, FUN = function(z){ z <- z[z > 0]; min(z) })
      for(i in 1:nrow(tmp)){
        tmp[ i, tmp[i, ] == 0 ] <- mins[i]
      }
    }
  } # end of 'min' method

  ## Replace OTU table
  phyloseq::otu_table(physeq) <- tmp
  return(physeq)
}

#' plot_lib_dist
#' Plot distribution of amplicon library sizes as a histogram
#'
#' @param Ps_obj (Required) A phyloseq object
#'
#' @author Roey Angel (https://github.com/roey-angel)
#' @return A ggplot object
#' @usage plot_lib_dist(Ps_obj)
#' @export

plot_lib_dist <- function(Ps_obj){
  require(ggplot2)
  require(scales)
  data.frame(sum = sample_sums(Ps_obj)) %>%
  ggplot(aes(x = sum)) +
    geom_histogram(color = "black",
                   fill = "indianred") +
    theme(panel.grid.minor = element_blank()) +
    labs(x = "Library size" , y = "Sample count") ->
    lib_dist_plot
  return(lib_dist_plot)
}

#' phyloseq_to_deseq2_safe
#' A wrapper for phyloseq::phyloseq_to_deseq2() but ensures that the right reference level is used
#'
#' phyloseq_to_deseq2() converts a phyloseq object to a deseq2 object. However for DESeq2 to work properly the reference level in the factor being tested needs to be the first level in the factor (R's default is alphabetical)
#'
#' @author Roey Angel (https://github.com/roey-angel)
#' @usage physeq_merge_samples(ps_obj, grouping_name = "Description")
#' @param ps (Required). A phyloseq object that has sample indices.
#'
#' @param test_condition (Required). A single character string matching a variable name in
#' the corresponding sample_data of \code{ps}.
#'
#' @param ref_level (Required). A single character string to be set as the reference level for DESeq2 (must be a factor level of test_condition)
#'
#' @return A DESeq2 object
#'
#' @seealso \code{\link{phyloseq::phyloseq_to_deseq2}}
#'
#' @export

## TODO:

phyloseq_to_deseq2_safe <- function(ps = ps_obj, test_condition = "Density.zone", ref_level = "Light") {
  require(magrittr)
  require(forcats)
  require(phyloseq)

  # critical for DESeq2 that the reference is the first level!!
  sample_data(ps)[[test_condition]] %<>% fct_relevel(., ref_level)
  expr <- as.formula(paste("~", test_condition))
  phyloseq_to_deseq2(ps, expr) %>%
    return(.)
}

mark_rare_taxa <- function(ps_obj, rank = "Phylum", rare_thresh = 0.01){
  require(dplyr)
  require(phyloseq)
  require(speedyseq)
  
  # glomerate to the "Rank" level
  ps_obj_glom <- tax_glom(ps_obj, 
                          rank, 
                          NArm = TRUE) 
  
  ps_obj_glom_rel <- transform_sample_counts(ps_obj_glom, 
                                             function(x) x / sum(x)) # transform to rel. ab.
  
  # convert to df
  ps_obj_df <- speedyseq::psmelt(ps_obj_glom_rel) # generate a df
  ps_obj_df %<>%
    mutate(Rank = as.character(!!sym(rank)))
   
  # group dataframe by Phylum, calculate sum rel. abundance
  ps_obj_df %>%
    group_by(!!sym(rank)) %>%
    summarise(Sum = sum(Abundance) / nsamples(ps_obj)) %>% 
    filter(Sum < rare_thresh) %>% # find Taxa whose mean rel. abund. is less than thresh
    pull(rank) -> 
    Rare_phyla 
  
  # change their name to "Rare"
  tax_table(ps_obj) %<>% 
    as.data.frame() %>%  
    rownames_to_column("OTU") %>% 
    mutate(across(rank, 
                  ~if_else(!!sym(rank) %in% Rare_phyla, "Rare", !!sym(rank)))) %>% 
    column_to_rownames("OTU") %>% 
    as.matrix() %>% 
    tax_table()
    return(ps_obj)
}

order_taxa <- function(ps_obj, rank = "Phylum", rel_abund = TRUE){
  require(dplyr)
  require(phyloseq)
  require(speedyseq)
  
  ps_obj %>%
    tax_glom(taxrank = rank) %>%                     # agglomerate at 'Rank' level
    {if(rel_abund) transform_sample_counts(., function(x) x / sum(x)) else .} %>% # convert to rel abundance 
    psmelt() %>%                                        # Melt to long format
    arrange(rank) %>%                                  # arrange by 'Rank'
    group_by(across(rank)) %>% 
    summarise(Abundance = sum(Abundance)) %>%
    arrange(desc(Abundance)) %>% 
    mutate(across(rank, ~factor(., levels = fct_inorder(.)))) %>%  
    mutate(across(rank, ~fct_relevel(., "Rare", after = Inf))) ->
    Taxa_order 
  
  return(Taxa_order)
}

prep_DESeq_data <- function(DESeq_results, ps_obj, sig_level = alpha_thresh, LFC = LFC_thresh, rank = "Phylum", rare_thresh = 0.01) {
  require(dplyr)
  require(magrittr)
  require(phyloseq)
  
  if (!is.list(DESeq_results)) {DESeq_results <- list(DESeq_results)} # convert to list if it is not (to support a vectorised run of DESEq2)
  
  # mark rare phyla
  ps_obj %>% mark_rare_taxa(., rank = rank, rare_thresh = rare_thresh) -> ps_obj
  
  # group dataframe by OTU, calculate median rel. abundance
  ps_obj %>%
    transform_sample_counts(., function(x) x / sum(x) * 100) %>% 
    taxa_sums(.) %>% 
    map_dbl(~(.x / nsamples(ps_obj))) %>% 
    enframe(name = "OTU", value = "Mean abundance (%)") -> 
    baseMean
  
  Taxa_order <- order_taxa(ps_obj)
  
  DESeq_results[[1]] %>% 
    as.data.frame() %>% 
    rownames_to_column(var = "OTU") %>% 
    left_join(., baseMean, by = "OTU") %>% # add mean abundance to results table
    bind_cols(., as(tax_table(ps_obj)[taxa_names(ps_obj) %in% .$OTU, ], "data.frame")) %>% # add taxnomy
    mutate(across(rank, ~factor(., levels = levels(Taxa_order$Phylum)))) %>% # order taxa by abundance
    mutate(Significance = if_else(padj < sig_level &
                            !is.na(padj) &
                            abs(lfcSE) > LFC,
                            "Pass",
                            "Fail"))  %>% 
    mutate(ymin = if_else(Significance == "Pass", log2FoldChange - lfcSE, NA_real_),
           ymax = if_else(Significance == "Pass", log2FoldChange + lfcSE, NA_real_)) -> # add error
    DESeq2plot

  return(DESeq2plot)
}

plot_DESeq <- function(DESeq_results, ps_obj, sig_level = alpha_thresh, LFC = LFC_thresh, rank = "Phylum", rare_thresh = 0.01, OTU_labels = FALSE, Y_val = "log2FoldChange", plot_title = "") {
  require(ggplot2)
  require(ggrepel)
  require(ggtext)
  
  DESeq2plot <- prep_DESeq_data(DESeq_results, ps_obj, sig_level, LFC, rank, rare_thresh)
  
  DESeq_summary <- tibble(Label = c(paste0("⬆", 
                                           sum(DESeq2plot$log2FoldChange > 0 & 
                                                 DESeq2plot$Significance == "Pass"),
                                           " (", nrow(DESeq2plot), ")")))
  
  pos <- position_jitter(width = 0.3, seed = 1)
  
  p <-
    ggplot(DESeq2plot) +
    geom_point(aes(
      x = !!sym(rank),
      y = !!sym(Y_val),
      colour = !!sym("Significance"),
      size = !!sym("Mean abundance (%)")),
      position = pos,
      alpha = 1 / 3,
      stroke = 0) +
    geom_linerange(aes(x = !!sym(rank),
                       y = !!sym(Y_val),
                       ymin = ymin,
                       ymax = ymax,
                       colour = !!sym("Significance")),
                   position = pos,
                   alpha = 1/5, 
                   show.legend = FALSE) +
    geom_text(
      data    = DESeq_summary,
      mapping = aes(x = Inf, y = Inf, label = Label),
      hjust   = 1.1,
      vjust   = 1.6
    ) +
    labs(x = "", y = "Log<sub>2</sub> fold change", title = plot_title) +
    labs(colour = paste("Significance at \n p <", sig_level), size = "Mean abundance (%)") +
    theme_grey(base_size = f_size, base_family = f_name) +
    theme(axis.text.x = element_text(angle = 45.0, vjust = 1, hjust = 1),
          panel.grid.major.x = element_blank(),
          panel.grid.minor.x = element_blank(),
          axis.title.y = element_markdown(),
          plot.title = element_markdown(size = f_size)) +
    guides(colour = guide_legend(override.aes = list(size = 5))) +
    # scale_colour_manual(values = c(ggpomological:::pomological_base[[7]], ggpomological:::pomological_palette[[1]])) +
    scale_colour_manual(values = c("#2b323f", "#c03728")) +
    scale_size_continuous(name = "Mean abundance (%)",
                          range = c(2, 8),
                          breaks = c(round(seq(min(DESeq2plot$`Mean abundance (%)`), max(DESeq2plot$`Mean abundance (%)`), length.out = 5), 1)))
  
  if (OTU_labels) {
    p <- p + geom_label_repel(
      aes(x = !!sym(rank), y = !!sym(Y_val)),
      size = 6,
      label = sub("Seq_([0-9]+)", "\\1", pull(DESeq2plot[DESeq2plot$Significance == "Pass", ], "OTU")),
      position = pos,
      data = DESeq2plot[DESeq2plot$Significance == "Pass", ],
      # nudge_x = 0.4,
      colour = "#4a4a4a",
      label.size = NA, 
      alpha = 0.75, 
      # fontface = 'bold',
      box.padding = 0.80,
      point.padding = 0.5
    )
  }
  return(p)
}

plot_otus_by_density <- function(ps_obj = Ps_obj_SIP_all_reps_l[[1]], 
                                 ASV2plot = filter(DESeq_res_SIP_each_rep_LFC_sig_df, 
                                                   Treatment == "Natural", 
                                                   Sample.no. == 1),
                                 ASV_colours = ggpomological:::pomological_palette[c(2, 4, 3, 1)],
                                 X_val = "Density..g.ml.1.", 
                                 Y_val = "Abundance", 
                                 shape_val = "Sample.no.",
                                 colour_val = "Label..18O.",
                                 topN = 30){
  require(ggpomological)
  require(dplyr)
  require(phyloseq)
  require(speedyseq)
  
  ps_obj %>% 
    transform_sample_counts(function(x) x/sum(x) * 100) %>% 
    prune_taxa(ASV2plot$ASV, .) %>% 
    prune_taxa(unique(arrange(ASV2plot, desc(log2FoldChange))$ASV)[1:topN], .) %>% 
    # prune_taxa(names(sort(taxa_sums(.), TRUE)[1:topN]), .) %>%
    psmelt() ->
    Incorporators_df
  
  ggplot(Incorporators_df, aes(x = !!sym(X_val),
                               y = !!sym(Y_val),
                               shape = as.factor(!!sym(shape_val)),
                               colour = as.factor(!!sym(colour_val)))) + 
    scale_colour_manual(values = ASV_colours) +
    # scale_colour_pomological() +
    geom_point(alpha = 1/2, size = 3) + 
    geom_line() +
    facet_wrap("OTU", scales = "free_y") +
    guides(colour = guide_legend(title = "Label"), 
           shape = guide_legend(title = "Label <sup>18</sup>O")) +
    labs(x = "Density (g ml<sup>-1</sup>)",
         title = paste(ASV2plot$Treatment[1])) +
    theme(legend.title = element_markdown(),
          axis.title.x = element_markdown(),
          plot.title = element_markdown())
  
  
}

plot_ggtree <- function(ps_obj, 
                        rank = "Phylum",
                        subrank = "Order",
                        Taxa2plot = "Actinobacteriota",
                        l_rows = 4){
  require(magrittr)
  require(ggplot2)
  require(ggtree)
  require(RColorBrewer)
  
  # subset (phyloseq subset_taxa doesn't support quasiquotation)
  ps_obj %>% 
    tax_table() %>%
    as("data.frame") %>%
    rownames_to_column("ASV") %>% 
    filter(., !!sym(rank) == Taxa2plot) %>% 
    column_to_rownames("ASV") %>% 
    as.matrix() %>% 
    tax_table() ->
    tax_table(ps_obj)
  
  tax_table(ps_obj) %>% 
    as("data.frame") %>% 
    pull(subrank) %>% 
    unique() %>% 
    length() ->
    n_colours

  p_tree <- ggtree(ps_obj,
                       layout = "rectangular") +
    geom_tippoint(aes(colour = !!sym(subrank)), 
                  size = 2, 
                  alpha = 1/2) +
    scale_color_manual(subrank, 
                       values = colorRampPalette(brewer.pal(11, "Spectral"))(n_colours)) +
    # geom_tiplab(hjust=-.3, size = 2) +
    geom_treescale(fontsize = 2) +
    guides(colour = guide_legend(nrow = l_rows,
                                 byrow = TRUE,
                                 title.position = "top")) +
    theme_tree(legend.title = element_markdown(size = f_size - 4),
               legend.position = "bottom", 
               legend.key.size = unit(0.1, "cm"),
               legend.text = element_markdown(size = f_size - 6),
               legend.box = "vertical", 
               legend.margin = margin(),
               plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"),
               plot.title = element_text(size = f_size - 2)) +
    # scale_colour_manual(values = mycolours) +
    ggtitle(Taxa2plot)
  return(p_tree)
}

plot_ggtree_heatmap <- function(p_ggtree, 
                                ps_obj,
                                DESeq_res_df,
                                rank = "Phylum",
                                Taxa2plot = "Actinobacteriota",
                                x = "Comparison_pair",
                                facet_names = "Treatment",
                                sample_colours = "black"){
  require(dplyr)
  require(ggplot2)
  require(viridis)
  require(ggtext)
  
  ps_obj %>% 
    tax_table() %>%
    as("data.frame") %>%
    rownames_to_column("ASV") %>% 
    filter(., !!sym(rank) == Taxa2plot) %>% 
    column_to_rownames("ASV") %>% 
    as.matrix() %>% 
    tax_table() ->
    tax_table(ps_obj)
  
  p_ggtree$data %>% 
    arrange(y, label) %>% 
    pull(label) %>% 
    unique() -> tip_order
  
  DESeq_res_df %>% 
    right_join(., tibble(ASV = taxa_names(ps_obj)), 
               by  = "ASV") ->
    DESeq_res_df_sub
  
colors <- sample_colours
labels2draw <- as.character(unique(pull(DESeq_res_df_sub, facet_names)))
labels <- setNames(glue("<i style='colors:{colors}'>{labels2draw}</i>"), labels2draw)

  DESeq_res_df_sub %>% 
    # filter(Labelled == "Labelled") %>% 
    mutate(log2FoldChange = ifelse(Labelled == "Labelled", log2FoldChange, NA_integer_)) %>% # retain values for labelled ASVs only
    select(ASV, !!sym(x), !!sym(facet_names), log2FoldChange) %>% 
    mutate(across(ASV, ~factor(., levels = tip_order))) %>%
    complete(., ASV) %>%
    ggplot(., aes(!!sym(x), ASV, fill = log2FoldChange)) + 
    geom_tile(colour = "white",
              size = 0.25) +
    # scale_fill_gradient(low = "gray", high = "darkred") +
    scale_fill_viridis(na.value = "white",
                       option = "inferno") +
    guides(fill = guide_legend(title = "Log<sub>2</sub> fold change",
                               title.position = "top")) +
    facet_wrap(vars(!!sym("Treatment")),
               labeller = as_labeller(labels),
               nrow = 1,
               scales = "free") +
    theme(axis.text.x = element_markdown(size = f_size - 6,
                                         angle = 45, 
                                         vjust = 1, 
                                         hjust = 1),
          panel.grid.major = element_blank(),
          axis.title.y = element_blank(),
          axis.title.x = element_markdown(size = f_size - 4),
          axis.text.y = element_blank(),
          axis.ticks.y = element_blank(),
          strip.background = element_blank(),
          strip.text =  element_markdown(size = f_size - 6),
          legend.key.size = unit(0.3, "cm"),
          legend.title = element_markdown(size = f_size - 4),
          legend.position = "bottom",
          legend.text = element_text(size = f_size - 6),
          plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm")) ->
    HM_plot
  
  return(HM_plot)
  
}

wrap_ggtree_heatmap <- function(ps_obj, 
                                DESeq_res_df,
                                rank = "Class",
                                subrank = "Order",
                                Taxa2plot = "Actinobacteria",
                                x = "Comparison_pair",
                                facet_names = "Treatment",
                                l_rows = 4,
                                pwidth = 4,
                                pheight = 7){
  p_t <- plot_ggtree(ps_obj, 
                     rank = rank,
                     subrank = subrank,
                     Taxa2plot = Taxa2plot,
                     l_rows = l_rows)
  p_hm <- plot_ggtree_heatmap(p_ggtree = p_t, 
                              ps_obj,
                              DESeq_res_df, 
                              rank = rank,
                              Taxa2plot = Taxa2plot,
                              x = x,
                              facet_names = facet_names,
                              sample_colours = brewer.pal(n = 11, 
                                                              "RdYlGn")[c(11, 1)])
  p_t_hm <- (p_t + p_hm) + 
    plot_layout(widths = c(1, 1))
  
  save_figure(paste0(fig.path, "Tree_HM_", Taxa2plot), 
              p_t_hm, 
              pwidth = pwidth, 
              pheight = pheight,
              dpi = 600)
  
  return(p_t_hm)
}

run_corncob_DA <- function(ps_obj = ps_obj_pairwise, var2test = "Treatment"){   # Test differential abundance for location
  da_obj <- differentialTest(formula = ~ get(var2test),
                             phi.formula = ~ get(var2test),
                             formula_null = ~ 1,
                             phi.formula_null = ~ get(var2test), 
                             test = "Wald", 
                             boot = FALSE,
                             data = ps_obj,
                             fdr_cutoff = 0.05,
                             full_output = TRUE)
  which(is.na(da_obj$p)) %>% names
  return(da_obj)
}

summarise_corncob <- function(ps_obj, da_obj, Taxa_rank = "Phylum", Rare_thresh = 0.1) {
  require(magrittr)
  require(dplyr)
  require(phyloseq)
  
  # Group dataframe by phylum, calculate phylum rel. abundance
  ps_obj %>% 
  transform_sample_counts(., function(x) x / sum(x)) %>%
  psmelt() %>% 
  group_by(!!sym(Taxa_rank)) %>%
  summarise(sums = sum(Abundance)/nsamples(ps_obj)) ->
  Sums

# Find Phyla whose median rel. abund. is less than Rare_thresh
Rare_taxa <- pull(Sums[Sums$sums <= Rare_thresh, Taxa_rank])

# Calculate mean abundance of each ASV (for plotting point size)
ps_obj %>%
  transform_sample_counts(., function(x) x / sum(x) * 100) %>% 
  taxa_sums(.) %>% 
  map_dbl(~(.x / nsamples(ps_obj))) %>% 
  enframe(name = "ASV", value = "Mean abundance (%)") -> 
  baseMean

# calculate prediction intervals
da_obj_intervals <- plot(da_obj, data_only = TRUE)

# grab all mu.XXX Estimates (differences in estimated population relative abundance)
map(da_obj$all_models, 15) %>% 
  map(., 2) %>% 
  unlist %>%  
  bind_cols(ASV = taxa_names(ps_obj), 
            tax_table(ps_obj), 
            `Differential abundance` = .,
            Significance = fct_recode(as_factor(taxa_names(ps_obj) %in% da_obj$significant_taxa), 
                                      Pass = "TRUE", Fail = "FALSE"),
            ymin = as.numeric(NA),
            ymax = as.numeric(NA)
  ) %>%
  left_join(., baseMean, by = "ASV") ->
  da_obj_df

# Add prediction interval data
da_obj_df %<>% rows_update(., tibble(ymin = da_obj_intervals$xmin, ASV = da_obj$significant_taxa), by = "ASV")
da_obj_df %<>% rows_update(., tibble(ymax = da_obj_intervals$xmax, ASV = da_obj$significant_taxa), by = "ASV")

# change rare phyla names to "Rare"
da_obj_df[da_obj_df$Phylum %in% Rare_taxa, Taxa_rank] <- 'Rare'  
return(da_obj_df)
}

make_da_df <- function(ps_obj = ps_obj_pairwise, da_obj = DA_obj, tax_rank = "Phylum") {
  DA_intervals <- plot(da_obj, data_only = TRUE)

  ps_obj %>%
    transform_sample_counts(., function(x) x / sum(x) * 100) %>% 
    taxa_sums(.) %>% 
    map_dbl(~(.x / nsamples(ps_obj))) %>% 
    enframe(name = "ASV", value = "Mean abundance (%)") -> 
    baseMean
  
  # grab all mu Estimates (differences in estimated population relative abundance)
  # extractCoefficients(da_Loc, taxa_names(.$data)) %>% 
  map(da_obj$all_models, 15) %>% # position 15 is the model coefficients 
    map(.,2) %>%
    map(., ~ifelse(is.null(.x), NA, .x)) %>% # this ensures that all Nulls are converted to NA (otherwise unlist() will drop them)
    unlist(.) %>% 
    bind_cols(ASV = taxa_names(ps_obj), 
              tax_table(ps_obj), 
              `Differential abundance` = .,
              Significance = fct_recode(as_factor(taxa_names(ps_obj) %in% da_obj$significant_taxa), Pass = "TRUE", Fail = "FALSE"),
              ymin = as.numeric(NA),
              ymax = as.numeric(NA)
    ) %>%
    left_join(., baseMean, by = "ASV") ->
    da_df
  
  # Add confidence intervals (only works on the significant ASVs)
  da_df %<>% rows_update(., tibble(ymin = DA_intervals$xmin, ASV = da_obj$significant_taxa), by = "ASV")
  da_df %<>% rows_update(., tibble(ymax = DA_intervals$xmax, ASV = da_obj$significant_taxa), by = "ASV")
  return(da_df)
}

plot_corncob <- function(da_df, p_title =  comparison, tax_rank = "Phylum", y_val = "Differential abundance", sig_level = 0.05, tax_order = Tax_order, ASV_labels = FALSE) {
  # Plot differential abundance model results 
  
  require(magrittr)
  require(ggplot2)
  require(ggrepel)
  
  pos <- position_jitter(width = 0.2, seed = 1)
  da_df %<>% 
    mutate_at(vars(matches(tax_rank)), as_factor) %>% 
    mutate(across(tax_rank, ~fct_expand(., levels(pull(tax_order, !!tax_rank))))) %>%  # just in case it doesn't match
    mutate(across(tax_rank, ~fct_relevel(., levels(pull(tax_order, !!tax_rank))))) %>% # reorder taxa according to what found in taxa_order
    mutate(across(tax_rank, ~fct_relevel(., "Rare", after = Inf))) 

  corncob_summary <- tibble(Label = c(paste0("⬆", 
                                             sum(da_df$`Differential abundance` > 0 &  da_df$Significance == "Pass"), 
                                             " ⬇", 
                                             sum(da_df$`Differential abundance` < 0 &  da_df$Significance == "Pass"), 
                                             " (", 
                                             nrow(da_df), 
                                             ")")))
  
  p <-
    ggplot(da_df) +
    geom_point(aes(
      x = !!sym(tax_rank),
      y = !!sym(y_val),
      colour = !!sym("Significance"),
      size = !!sym("Mean abundance (%)")),
      position = pos, 
      alpha = 2 / 3, 
      stroke = 0) +
    geom_linerange(aes(x = !!sym(tax_rank),
                       y = !!sym(y_val),
                       ymin = `ymin`,
                       ymax = `ymax`,
                       colour = !!sym("Significance")),
                   position = pos,
                   alpha = 1/5, 
                   show.legend = FALSE) +
    geom_text(
      data    = corncob_summary,
      mapping = aes(x = Inf, y = Inf, label = Label),
      hjust   = 1.1,
      vjust   = 1.6
    ) +
    xlab("") +
    ylab("Differential abundance") +
    labs(colour = paste("Significance at \n p <", sig_level), size = "Mean abundance (%)") +
    theme_grey(base_size = 18, ) +
    theme(axis.text.x = element_text(angle = 45.0, vjust = 1, hjust = 1),
          panel.grid.major.x = element_blank(),
          panel.grid.minor.x = element_blank()) +
    guides(colour = guide_legend(override.aes = list(size = 5))) +
    scale_colour_manual(values = c(ggpomological:::pomological_base[[7]], ggpomological:::pomological_palette[[1]])) +
    scale_size_continuous(name = "Mean abundance (%)",
                          range = c(2, 8),
                          breaks = c(round(seq(min(da_df$`Mean abundance (%)`), max(da_df$`Mean abundance (%)`), length.out = 5), 1)))
  
  if (ASV_labels) {
    p <- p + geom_label_repel(
      aes(x = !!sym(tax_rank), y = !!sym(y_val)),
      size = 6,
      label = sub("Seq_([0-9]+)", "\\1", pull(da_df[da_df$Significance == "Pass", ], "ASV")),
      position = pos,
      data = da_df[da_df$Significance == "Pass", ],
      # nudge_x = 0.4,
      colour = "#4a4a4a",
      label.size = NA, 
      alpha = 0.75, 
      # fontface = 'bold',
      force = 1,
      force_pull = 1,
      box.padding = 0.4,
      point.padding = 0.1,
      max.overlaps = 100
    )
  }
  p <- p + labs(title = p_title)
  return(p)
}

plot_top_ASVs_DA <- function(ps_obj = ps_obj_pairwise, p_title =  comparison, da_df = DA_df, vars2test = "Treatment", abundance_col = "Mean abundance (%)", rank_by = "Differential abundance", joint_name = "Joint.sample.name", Ntop = 12){
  # adapted from https://link.springer.com/protocol/10.1007%2F978-1-4939-8728-3_10
  require("phyloseq")
  require("ggplot2")
  require("ggpomological")
  
  # Rank ASVs according to rank_by
  da_df %>% 
  filter(Significance == "Pass") %>% 
  dplyr::select(OTU, Phylum, !!sym(abundance_col), !!sym(rank_by)) %>%
  arrange(desc(abs(!!sym(rank_by)))) -> ASV_rank
  if (nrow(ASV_rank) < Ntop) Ntop <- nrow(ASV_rank) # in case there are less than Ntop sig ASVs
  ASV_rank %>% .[1:Ntop, ] %>% pull(OTU) -> ASV_names # keep only
  
  # Get rel. abund. transform
  ps_RA <- transform_sample_counts(ps_obj, function(x) x/sum(x) * 100)

  if (is.na(ASV_names[1]) | is.null(ASV_names[1])) {
    message("No significant differentially abundant ASVs to display")
  } else {
    gtab <- tibble(
      pivot_longer(as_tibble(get_sample(ps_RA, i = ASV_names)), 
                   everything(),
                   names_to = "OTU", 
                   values_to = "Rel_abundance"),
      SAMPLE_ID = as_factor(rep(unlist(get_variable(ps_RA, joint_name)), each = Ntop)),
      TREATMENT = as_factor(rep(get_variable(ps_RA, vars2test), each = Ntop)))
    
    # Remove comparison levels from SAMPLE_ID
    gtab %<>% mutate(across(SAMPLE_ID, ~str_replace_all(., paste0(levels(pull(gtab, "TREATMENT")), " ", collapse = "|"), ""))) # remove the levels participating in the comparison from the names
    
    # Add a bothZero column
    gtab %<>% group_by(SAMPLE_ID, OTU) %>% mutate(., BothZero := all(Rel_abundance == 0)) 
    
    # Create a dummy min-value for display
    gtab %<>% group_by(OTU) %>% mutate(Zero = min(Rel_abundance[(Rel_abundance > 0.0)], na.rm = TRUE)/10)
    # Replace all zeros with the dummy min-value
    gtab %<>% group_by(SAMPLE_ID, OTU) %>% mutate(Rel_abundance = replace(Rel_abundance, Rel_abundance == 0.0, Zero[Rel_abundance == 0.0]))
    gtab$SAMPLE_ID
    
    pointSize <- 3
    p <- ggplot(data = gtab,
                mapping = aes(
                  x = TREATMENT, 
                  y = Rel_abundance,
                  color = TREATMENT,
                  shape = TREATMENT)) + 
      facet_wrap(~OTU, scales = "free_y") +
      # Both not zero
      # geom_point(
      #   data = filter(gtab, BothZero == FALSE),
      #   size = pointSize, 
      #   alpha = 0.8) +
      # Both Zero
      geom_point(
        # data = filter(gtab, BothZero == TRUE),
        size = pointSize, 
        alpha = 0.8) + #,
        # position = position_jitter(width = 0.2, height = 0)) + 
      geom_path(
        # data = filter(gtab, BothZero == FALSE),
        mapping = aes(group = SAMPLE_ID),
        color = "darkgray",
        size = 0.25,
        position = position_jitter(width = 0, height = 0.001)) +
      geom_text(mapping = aes(label = SAMPLE_ID),
                data = gtab %>% filter(Rel_abundance > Zero) %>% distinct(SAMPLE_ID, .keep_all = TRUE),
                color = "black",
                size = 2,
                nudge_x = -0.15) +
      scale_colour_manual(values = c(ggpomological:::pomological_base[[7]], ggpomological:::pomological_palette[[1]])) +
      # scale_y_sqrt() +
      scale_y_log10() +
      theme_bw() + 
      theme(text = element_text(size = f_size),
            legend.position = "none") +
      scale_size_continuous(range = c(2, 5)) +
      ylab("Abundance (%)")
    # ggtitle(paste("Abundance plot for ASV", ASV))
    p <- p + labs(title = p_title)
    return(p)
  }
}

wrap_corncob <- function(ps_obj = Ps_obj_subset, var2sub = "Spill.Treatment", var2test = "Treatment", comparison = Comparisons[1], glom_taxa = FALSE, rank2glom = "Order", tax_rank = "Phylum") {
  
  comparison_str <- unlist(str_split(comparison, " vs. "))
  
  ps_obj_pairwise <- subset_physeq4pairwise(ps_obj, var2sub = var2sub, comparison_str = comparison_str, glom_taxa = glom_taxa, rank2glom = rank2glom)
  
  #  Remove species with prevalence < X%
  ps_obj_pairwise <<- filter_taxa_by_prevalence(ps_obj = ps_obj_pairwise, prevalence = 0.1)
  
  DA_obj <- run_corncob_DA(ps_obj = ps_obj_pairwise, var2test = var2test)
  
  # DA_df <- summarise_corncob(ps_obj = ps_obj_pairwise, da_obj = DA_obj, Taxa_rank = tax_rank, Rare_thresh = 0.01)
  DA_df <- make_da_df(ps_obj = ps_obj_pairwise, da_obj = DA_obj, tax_rank = tax_rank)
  
  DA_df %>% 
    filter(Significance == "Pass") %>% 
  write.csv(., file = paste0("corncob", "_", paste0(comparison, collapse = "_"), ".csv"))
  
  p_corncob <- plot_corncob(da_df = DA_df, 
                            p_title = comparison, 
                            tax_rank = tax_rank,
                            y_val = "Differential abundance", 
                            sig_level = 0.05, 
                            tax_order = Tax_order, 
                            ASV_labels = F)
  
  p_corncob <- p_corncob + scale_y_continuous(limits = c(-10, 10))
  save_figure(paste0(fig.path, "corncob_", str_replace_all(comparison," ", "_")), 
              p_corncob, 
              pwidth = 15, 
              pheight = 10,
              dpi = 600)
  
  p_corncob_ASVs_l <- plot_top_ASVs_DA(ps_obj = ps_obj_pairwise, 
                                       p_title = comparison,
                                       vars2test = "Treatment",
                                       da_df = DA_df,
                                       abundance_col = "Mean abundance (%)", 
                                       rank_by = "Differential abundance",
                                       Ntop = 12
  )
  
  save_figure(paste0(fig.path, "corncob_", str_replace_all(comparison," ", "_"), "_ASVs"), 
              p_corncob_ASVs_l, 
              pwidth = 15, 
              pheight = 10,
              dpi = 600)
}
```

## Differential abundance modelling of SIP gradients
Here we attempt to detect ASVs that were labelled with ^18^O in thr soil incubations using differential abundance modelling.
Using corncob [@martin_modeling_2020] we compare the relative abundance of each ASV in the fractions where ^18^O-labelled DNA is expected to be found (>1.70 g ml^-1^; AKA 'heavy' fractions) in the labelled gradients to the heavy fractions in the unlabelled gradient. The method has been previously described in Angel et al., [-@angel_application_2018].

### Setting general parameters:
```{r general parameters, cache=T}
set.seed(2021)
alpha_thresh <- 0.05
LFC_thresh <- 0.26
samples_prep_path <- "./"
data_path <- "./DADA2_pseudo/"
Proj_name <- "Zin_SIP"
Ps_file <- paste0(Proj_name, "_filt_wTree.Rds")
Tree_file <- "./Tree/DADA2.Seqs_decontam_filtered.filtered.align.treefile"
```

### Load phyloseq object
This phyloseq object was created in [05_Taxonomical_analysis.html](05_Taxonomical_analysis.html) by including the iqtree-calculated tree.
The phyloseq object excludes contaminants, all sequences classified as eukaryota, chloroplast, mitochondria or unknown, taxa with low prevalence. 
```{r load phyloseq, cache=T}
Ps_obj <- readRDS(file = paste0(data_path, Ps_file))
```

### Beta diversity analysis
Let us look first at the dissimilarity in community composition between the different fractions. If the labelling was strong enough we should see a deviation of (some of) the heavy fractions from the light ones. However, a lack of a significant deviation does not mean unsuccessful labelling because if only a small minority of the community was labelled we might not see it here (but we will, hopefully, see it using corncob modelling).

```{r beta div joint, cache=T}
(mod1 <- adonis(vegdist(otu_table(Ps_obj), method = "horn") ~ Treatment + Library.size,
  data = as(sample_data(Ps_obj), "data.frame"),
  permutations = 999
))

plot_lib_dist(Ps_obj)

Ps_obj %>%
  scale_libraries(round = "round") ->
  Ps_obj_SIP_scaled
  
plot_lib_dist(Ps_obj_SIP_scaled)

(mod2 <- adonis(vegdist(otu_table(Ps_obj_SIP_scaled), method = "horn") ~ Treatment + Library.size,
  data = as(sample_data(Ps_obj_SIP_scaled), "data.frame"),
  permutations = 999
))


(mod3 <- adonis(vegdist(otu_table(Ps_obj_SIP_scaled), method = "horn") ~ Treatment * Density.zone,
  data = as(sample_data(Ps_obj_SIP_scaled), "data.frame"),
  permutations = 999
))

Treatment_disp <- betadisper(vegdist(otu_table(Ps_obj_SIP_scaled), method = "horn"), get_variable(Ps_obj_SIP_scaled, "Treatment"))
permutest(Treatment_disp)
plot(Treatment_disp)
#Comparison_pair_disp <- betadisper(vegdist(otu_table(Ps_obj_SIP_scaled), method = "horn"), get_variable(Ps_obj_SIP_scaled, "Comparison_pair"))
#permutest(Oxygen_disp)
#plot(Oxygen_disp)
#Hours_disp <- betadisper(vegdist(otu_table(Ps_obj_SIP_scaled), method = "horn"), get_variable(Ps_obj_SIP_scaled, "Hours"))
#permutest(Hours_disp)
#plot(Hours_disp)
Density_disp <- betadisper(vegdist(otu_table(Ps_obj_SIP_scaled), method = "horn"), get_variable(Ps_obj_SIP_scaled, "Density.zone"))
permutest(Density_disp)
plot(Density_disp)
```

```{r ordinations, fig.height=12, cache=T}
Ord <- ordinate(Ps_obj_SIP_scaled, "CAP", "horn", 
                formula =  ~ Treatment * Density.zone)
explained <- as.numeric(format(round(eigenvals(Ord)/sum(eigenvals(Ord)) * 100, 1), nsmall = 1))
Ord_plt <- plot_ordination(Ps_obj, Ord, type = "samples", color = "Label..18O.", justDF = TRUE)

p_ord_joint <- ggplot(Ord_plt) +
  geom_point(aes(
               x = CAP1,
               y = CAP2,
               color = Label..18O.,
               size = Density..g.ml.1.,
               shape = Treatment
             ), alpha = 2 / 3) +
  guides(colour = guide_legend(title = "Labelling"), 
         size = guide_legend(title = "Density (g ml<sup>-1</sup>)"),
         shape = guide_legend(title = "Treatment")) +
  scale_colour_locuszoom() +
  # scale_colour_manual(values = Gradient.colours) +
  # scale_fill_manual(values = Gradient.colours, guide = "none") +
  labs(x = sprintf("CAP1 (%s%%)", explained[1]),
  y = sprintf("CAP2 (%s%%)", explained[2])) +
  coord_fixed(ratio = sqrt(explained[2] / explained[1])) +
   theme(legend.justification = "top",
         legend.title = element_markdown(size = 11)
         ) +
  scale_size_continuous(breaks = round(c(seq(min(Ord_plt$Density..g.ml.1.), 
                                       max(Ord_plt$Density..g.ml.1.), 
                                       length.out = 5), 
                                   1), 4),
                        range = c(0.1, 5)) +
  facet_grid("Treatment") +
  # ggtitle("Joint analysis") +
  NULL

save_figure(paste0(fig.path, "Oridnation"), 
            p_ord_joint, 
            pwidth = 10, 
            pheight = 8,
            dpi = 600)

knitr::include_graphics(paste0(fig.path, "Oridnation", ".png"))
```

### Subset the dataset
Because the corncob models will be run on each gradient-pair separately, we need to subset This is easily done using `HTSSIP::phyloseq_subset` [@youngblut_htssip_2018]
```{r subset dataset, cache=T}
# split, ignore replicates (for labelled ASV plots)
# test_expr_1 <- "(Site == '${Site}' & Oxygen == '${Oxygen}' & Label..13C. == 'Unlabelled') | (Site == '${Site}'  & Oxygen == '${Oxygen}' & Label..13C. == '${Label..13C.}')"
# params_1 <- get_treatment_params(Ps_obj_SIP, c("Site",
#                                    "Oxygen",
#                                    "Glucose",
#                                    "Label..13C."),
#                      "Label..13C. != 'Unlabelled'")

test_expr_1 <- "Treatment == '${Treatment}'"

params_1 <- get_treatment_params(Ps_obj, c("Treatment"))

Ps_obj %>% 
  subset_samples(Density.zone == "Heavy") %>% 
  phyloseq_subset(., params_1, test_expr_1) ->
  Ps_obj_SIP_all_reps_l

names(Ps_obj_SIP_all_reps_l) %<>%
  map(., ~str_remove_all(.x, "\\s\\|\\s.*")) %>%
  map(., ~str_remove_all(.x, "\\(|\\)|Treatment == |'"))

#split, include time points (for corncob modelling)
test_expr_2 <- "(Treatment == '${Treatment}' & Comparison_pair  == '${Comparison_pair}')"
params_2 <- get_treatment_params(Ps_obj, c("Treatment", 
                                   "Comparison_pair"))

# Generate a list of subsetted phyloseq objects
Ps_obj %>% 
  subset_samples(Density.zone == "Heavy") %>% 
  phyloseq_subset(., params_2, test_expr_2) ->
  Ps_obj_SIP_each_rep_l

names(Ps_obj_SIP_each_rep_l) %<>%
  map(., ~str_remove_all(.x, "\\s\\|\\s.*")) %>%
  map(., ~str_remove_all(.x, "\\(|\\)|Treatment == |Comparison_pair  == |'"))
```

### Differential abundance models
Now run the differential abundance models using corncob. We then filter the resutls to include only ASVs with Log_2_ fold change >`LFC_thresh` and significant at P<`alpha_thresh`. Lastly, we run 'LFC-shrinking' based on Stephens [-@stephens_fdr_2016].
```{r corncob models by time, cache=T}


rare_thresh = 0.01
rank = "Phylum"

# mark rare phyla
Ps_obj_SIP_each_rep_l[[.x]] %>% mark_rare_taxa(., rank = rank, rare_thresh = rare_thresh) -> Ps_obj_SIP_each_rep_l[[.x]]

Taxa_order <- order_taxa(Ps_obj_SIP_each_rep_l[[.x]], rank = "Phylum", rel_abund = TRUE)

DA_obj <- run_corncob_DA(ps_obj = Ps_obj_SIP_each_rep_l[[.x]], var2test = "Label..18O.")


DA_obj <- differentialTest(formula = ~ get(var2test),
                             phi.formula = ~ 1,
                             formula_null = ~ 1,
                             phi.formula_null = ~ 1, 
                             test = "Wald", 
                             boot = FALSE,
                             data = Ps_obj_SIP_each_rep_l[[.x]],
                             fdr_cutoff = 0.025,
                             full_output = TRUE)
which(is.na(DA_obj$p)) %>% names

DA_df <- make_da_df(ps_obj = Ps_obj_SIP_each_rep_l[[.x]], da_obj = DA_obj, tax_rank = tax_rank)
  
DA_df %>% 
  filter(Significance == "Pass") %>% 
  write.csv(., file = paste0("corncob", "_", paste0(comparison, collapse = "_"), ".csv"))

p_corncob <- plot_corncob(da_df = DA_df, 
                          p_title = "test", 
                          tax_rank = tax_rank,
                          y_val = "Differential abundance", 
                          sig_level = 0.05, 
                          tax_order = Taxa_order, 
                          ASV_labels = F)

p_corncob <- p_corncob + scale_y_continuous(limits = c(-10, 10))
  
  

DA_df_l <- mclapply(seq(length(Comparisons)),
                        function(x) wrap_corncob(ps_obj = Ps_obj_subset_tagged, 
                                                 var2sub = "Spill.Treatment",
                                                 var2test = "Treatment",
                                                 comparison = Comparisons[x],
                                                 glom_taxa = F,
                                                 tax_rank = "Phylum"
                        ), 
                        mc.cores = length(Comparisons))

plots2display <- list.files(path = paste0(fig.path), 
                    pattern = "^corncob_(.*).png$",
                    full.names = TRUE)

# tryCatch(knitr::include_graphics(paste0(plots2display, ".png")))

plots2display <- list.files(path = paste0(fig.path), 
                    pattern = "^corncob_(.*).png$",
                    full.names = TRUE)













# generate a corncob object
corncob_obj_SIP_each_rep_l <- mclapply(Ps_obj_SIP_each_rep_l, 
                                   function(x) {phyloseq_to_deseq2_safe(x, 
                                                                        test_condition = "Label..18O.", 
                                                                        ref_level = "Unlabelled")}, 
                                   mc.cores = nrow(params_2))


# run dds pipeline
corncob_obj_SIP_each_rep_l %<>% mclapply(., 
                                     function(x) {DESeq(x, 
                                                        test = "Wald", 
                                                        fitType = "local")}, 
                                     mc.cores = nrow(params_2)) # run dds pipeline

# extract results from a corncob analysis
corncob_res_SIP_each_rep_l  <- mclapply(corncob_obj_SIP_each_rep_l, 
                             function(x) {
                               results(x, 
                                       altHypothesis = "greater",
                                       alpha = alpha_thresh, 
                                       contrast = c("Label..18O.", "Labelled", "Unlabelled"))}, # redundant if phyloseq_to_deseq2_safe() was used but doesn't hurt
                             mc.cores = nrow(params_2)) 

corncob_res_SIP_each_rep_LFC_l <- mclapply(corncob_obj_SIP_each_rep_l, 
                                     function(x) {
                                       results(x,
                                               lfcThreshold = LFC_thresh,
                                               altHypothesis = "greater",
                                               alpha = alpha_thresh,
                                               contrast = c("Label..18O.", "Labelled", "Unlabelled"))}, # redundant if phyloseq_to_deseq2_safe() was used but doesn't hurt
                                     mc.cores = nrow(params_2)) # Extract results from a corncob analysis


corncob_res_SIP_each_rep_LFC_shrink_l <- map(seq(length(corncob_obj_SIP_each_rep_l)), 
                                             ~lfcShrink(corncob_obj_SIP_each_rep_l[[.x]],
                                                         res = corncob_res_SIP_each_rep_LFC_l[[.x]],
                                                         coef = "Label..18O._Labelled_vs_Unlabelled",
                                                         type = "ashr"))
names(corncob_res_SIP_each_rep_LFC_shrink_l) <- names(corncob_res_SIP_each_rep_LFC_l)

# Compare
plotMA(corncob_res_SIP_each_rep_l[[2]], ylim = c(-2,2))
plotMA(corncob_res_SIP_each_rep_LFC_l[[2]], ylim = c(-2,2))
plotMA(corncob_res_SIP_each_rep_LFC_shrink_l[[2]], ylim = c(-2,2))

# summarise results (lfcShrink doesn't change the values)
# map2(corncob_res_SIP_byTime_l, print(names(corncob_res_SIP_byTime_l)), ~summary(.x)) # summarise results
# for (i in seq(1, length(corncob_res_SIP_byTime_l))) { # didn't manage with map
#   print(names(corncob_res_SIP_byTime_l[i]))
#   summary(corncob_res_SIP_byTime_l[[i]])
# }

for (i in seq(1, length(corncob_res_SIP_each_rep_LFC_l))) { # didn't manage with map
  print(names(corncob_res_SIP_each_rep_LFC_l[i]))
  summary(corncob_res_SIP_each_rep_LFC_l[[i]])
}

# Store labelled OTUs and save them to a file
# corncob_res_SIP_byTime_l %>% 
#   map(., ~subset(.x, padj < alpha_thresh & log2FoldChange > LFC_thresh)) %>% 
#   map(., ~as.data.frame(.x)) %>% 
#   map(., ~rownames_to_column(.x, "ASV")) %>% 
#   bind_rows(., .id = "Comparison") %>% 
#   arrange(Comparison, desc(baseMean)) %T>% 
#   write_csv(., file = "corncob_byTime_a-0.05.txt") ->
#   corncob_res_SIP_byTime_df

corncob_res_SIP_each_rep_LFC_shrink_l %>% 
  map(., ~subset(.x, padj < alpha_thresh & log2FoldChange > LFC_thresh)) %>% 
  map(., ~as.data.frame(.x)) %>% 
  map(., ~rownames_to_column(.x, "ASV")) %>% 
  bind_rows(., .id = "Comparison") %>% 
  arrange(Comparison, desc(baseMean))  %>% 
  separate(., "Comparison" ,c("Treatment","Comparison_pair"), sep = " & ") %T>% 
  write_csv(., file = "corncob_each_rep_a-0.05_LFC0-322.txt") ->
  corncob_res_SIP_each_rep_LFC_sig_df
```

#### Inspect results
```{r vis DES res, cache=T}
corncob_res_SIP_each_rep_LFC_sig_df %>% 
  get_variable() %>% 
  select_if(is.numeric) %>% 
  vis_value()

corncob_res_SIP_each_rep_LFC_sig_df %>% 
  get_variable() %>% 
  select_if(is.numeric) %>% 
  vis_cor()
```

#### Plot differential abundance models
```{r plot corncob models, fig.height=14, fig.width=12, cache=T}
# ps_obj <- Ps_obj
# corncob_results <- corncob_res_SIP_byTime_LFC0.322_l[9]
# plot_corncob(corncob_results, ps_obj, plot_title = names(corncob_results))

corncob_plots <- map(seq(length(corncob_res_SIP_each_rep_LFC_shrink_l)), 
                        ~plot_corncob(corncob_res_SIP_each_rep_LFC_shrink_l[.x],  
                                                Ps_obj, plot_title = names(corncob_res_SIP_each_rep_LFC_shrink_l[.x])))

Natural_corncob <- ((corncob_plots[[1]] + 
                     theme(legend.position = "none") +
                     theme(axis.text.x = element_blank())) +
                    (corncob_plots[[2]] + 
                       theme(legend.position = "none", 
                             axis.text.x = element_blank(), 
                             axis.title.y = element_blank())) +
                    (corncob_plots[[3]] + 
                       theme(legend.position = "none",
                             axis.text.x = element_blank())) +
                    (corncob_plots[[4]] + 
                       theme(legend.position = "none", 
                             axis.text.x = element_blank(), 
                             axis.title.y = element_blank())) +
                    (corncob_plots[[5]] + 
                       theme(legend.position = "none", 
                             axis.title.y = element_blank())) + 
                    plot_layout(ncol = 2, guides = "collect") & 
                    theme(legend.position = 'bottom'))

save_figure(paste0(fig.path, "Natura_corncob"), 
            Natural_corncob, 
            pwidth = 14, 
            pheight = 12,
            dpi = 600)

knitr::include_graphics(paste0(fig.path, "Natural_corncob", ".png"))

Restored_corncob <- ((corncob_plots[[6]] + 
                     theme(legend.position = "none") +
                     theme(axis.text.x = element_blank())) +
                    (corncob_plots[[7]] + 
                       theme(legend.position = "none", 
                             axis.text.x = element_blank(), 
                             axis.title.y = element_blank())) +
                    (corncob_plots[[8]] + 
                       theme(legend.position = "none",
                             axis.text.x = element_blank())) +
                    (corncob_plots[[9]] + 
                       theme(legend.position = "none", 
                             axis.text.x = element_blank(), 
                             axis.title.y = element_blank())) +
                    (corncob_plots[[10]] + 
                       theme(legend.position = "none", 
                             axis.title.y = element_blank())) + 
                    plot_layout(ncol = 2, guides = "collect") & 
                    theme(legend.position = 'bottom'))

save_figure(paste0(fig.path, "Restored_corncob"), 
            Restored_corncob, 
            pwidth = 14, 
            pheight = 12,
            dpi = 600)

knitr::include_graphics(paste0(fig.path, "Restored_corncob", ".png"))
```

### Plot labelled ASVs
```{r plot labelled ASVs, fig.height=12, fig.width=16, cache=T}
plot_combintions <- crossing(Treatment = c("Natural", "Restored"))

Labelled_ASVs <- map(seq(length(Ps_obj_SIP_all_reps_l)), ~plot_otus_by_density(Ps_obj_SIP_all_reps_l[[.x]], 
                     ASV2plot = filter(corncob_res_SIP_each_rep_LFC_sig_df, Treatment == plot_combintions$Treatment[.x])))

map(seq(length(Ps_obj_SIP_all_reps_l)), 
    ~save_figure(paste0(fig.path, "Labelled_ASVs_", paste(plot_combintions[.x, ], collapse = "_")), 
                 Labelled_ASVs[[.x]], 
                 pwidth = 16, 
                 pheight = 12,
                 dpi = 600))

plots2display <- list.files(path = paste0(fig.path), 
                    pattern = "^Labelled_ASVs_(.*).png$",
                    full.names = TRUE)

knitr::include_graphics(plots2display)
```

#### Plot phylogenetic trees with heatmaps
```{r Plot trees, fig.height=8, fig.width=10, cache=T}
c("Natural", "Restored")  ->
  col_order

corncob_res_SIP_each_rep_LFC_shrink_l %>% 
  map(., ~as.data.frame(.x)) %>% 
  map(., ~rownames_to_column(.x, "ASV")) %>% 
  bind_rows(., .id = "Comparison") %>% 
  # filter(str_detect(Comparison, "Labelled")) %>% # remove unlabelled samples [c(-5, -10, -15, -20)]
  mutate(Labelled = ifelse(padj < alpha_thresh & log2FoldChange > LFC_thresh, "Labelled", "Unlabelled")) %>% 
  # arrange(Comparison, desc(baseMean)) %>% 
  separate(., "Comparison" ,c("Treatment","Comparison_pair"), sep = " & ") %>% 
  mutate(Treatment_pair = paste(Treatment, Comparison_pair)) %>% 
  mutate(across(Treatment_pair, ~as.factor(.))) %>% 
  # mutate(Site_Oxygen = factor(paste0(Site, "-", Oxygen),
  #                             levels = c("Plesne-Oxic", "Plesne-Anoxic", "Certovo-Oxic", "Certovo-Anoxic"),
  #                             labels = c("Pl-Ox", "Pl-Anox", "Ct-Ox", "Ct-Anox"))) %>%
  # mutate(across(c("Hours"), ~factor(., 
  #                                   levels = c("12 h", "24 h", "48 h", "72 h", "216 h"),
  #                                   labels = c("12", "24", "48", "72", "216")))) 
  identity() ->
  # mutate(Site_oxygen = paste(Site, Oxygen)) ->
  corncob_res_SIP_each_rep_df

# Summarise number of labelled and unlabelled ASVs
corncob_res_SIP_each_rep_df %>% 
  group_by(Labelled) %>% 
  summarise(n = n()) 

# detect taxa with NA from corncob analysis
corncob_res_SIP_each_rep_df %<>% 
  filter(!is.na(Labelled)) #%>% 
  # pull(Labelled) -> 
  # bad_seqs

# remove NA taxa from PS obj
Ps_obj %>% 
  # prune_taxa(setdiff(taxa_names(Ps_obj), "Seq_2375"), .) %>% # outlier
  prune_taxa(corncob_res_SIP_each_rep_df$ASV, .) ->
  Ps_obj_SIP4tree_plot


# Remove long name
tax_table(Ps_obj_SIP4tree_plot)[, "Order"] %<>%  str_replace_all(., "Gammaproteobacteria Incertae Sedis", "Incertae Sedis")


taxa2plot <- tibble(rank = c(rep("Class", 3), rep("Phylum", 4)), 
                    subrank = c(rep("Order", 3), rep("Class", 4)), 
                    Taxa2plot = c("Actinobacteria", 
                                  "Alphaproteobacteria", 
                                  "Gammaproteobacteria", 
                                  "Gemmatimonadota",
                                  "Cyanobacteria",
                                  "Bacteroidota",
                                  "Firmicutes"),
                    # l_rows = c(4, 5, 6, 3, 3, 3, 3),
                    # pwidth = c(5, 6, 8, 3, 3, 3, 3), 
                    # pheight = c(rep(10, 7)),)
                    l_rows = c(rep(4, 7)),
                    pwidth = c(rep(5, 7)), 
                    pheight = c(rep(8, 7)),)

tree_p_l <- map(seq(nrow(taxa2plot)), 
                ~wrap_ggtree_heatmap(Ps_obj_SIP4tree_plot,
                                     corncob_res_SIP_each_rep_df,
                                     rank = taxa2plot$rank[.x],
                                     subrank = taxa2plot$subrank[.x],
                                     Taxa2plot = taxa2plot$Taxa2plot[.x],
                                     l_rows = 4,
                                     pwidth = 5,
                                     pheight = 8))

trees2display <- list.files(path = paste0(fig.path), 
                    pattern = "^Tree_HM_(.*).png$",
                    full.names = TRUE)

knitr::include_graphics(trees2display)

all_trees <- ((tree_p_l[[1]] | tree_p_l[[2]] + guides(fill = FALSE) | tree_p_l[[3]] + guides(fill = FALSE) | tree_p_l[[6]] + guides(fill = FALSE)) / (tree_p_l[[4]] + guides(fill = FALSE) | tree_p_l[[5]] + guides(fill = FALSE) | tree_p_l[[7]] + guides(fill = FALSE) | plot_spacer())) + plot_layout(heights = c(2, 1))

save_figure(paste0(fig.path, "all_trees"), 
            all_trees, 
            pwidth = 16, 
            pheight = 18,
            dpi = 900)
```

```{r colophon, eval=T}
sessioninfo::session_info() %>%
  details::details(
    summary = 'Current session info',
    open    = TRUE
 )
```

## References
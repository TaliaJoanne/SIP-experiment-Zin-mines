---
title: "Zin SIP"
subtitle: "06 Differential abundance modelling using DESeq2"
author: "Roey Angel"
email: "roey.angel@bc.cas.cz"
date: "`r Sys.Date()`"
bibliography: references.bib
link-citations: yes
csl: fems-microbiology-ecology.csl
always_allow_html: true
output:
  rmarkdown::github_document:
    toc: true
    toc_depth: 5
    number_sections: false
    dev: "png"
    df_print: "kable"
    keep_html: true
---

```{r libraries, include=F, message=FALSE, warning = FALSE}
Sys.setenv(R_LIBS_USER = "~/R/library") # Uncomment if you have no write access to R path change to local library dir
.libPaths(c(Sys.getenv("R_LIBS_USER"), .libPaths())) # Uncomment if you have no write access to R path
library(extrafont) # Tools for using fonts, CRAN v0.17
library(tidyverse) # Easily Install and Load the 'Tidyverse', CRAN v1.3.0 
library(magrittr) # A Forward-Pipe Operator for R, CRAN v2.0.1 
library(scales) # Scale Functions for Visualization, CRAN v1.1.1 
library(RColorBrewer) # ColorBrewer Palettes, CRAN v1.1-2
library(svglite) # An 'SVG' Graphics Device, CRAN v1.2.3.2 
library(viridis) # Default Color Maps from 'matplotlib', CRAN v0.5.1
library(ggsci) # Scientific Journal and Sci-Fi Themed Color Palettes for 'ggplot2', CRAN v2.9
library(ggtext) # Improved Text Rendering Support for 'ggplot2', CRAN v0.1.1
library(kableExtra) # Construct Complex Table with 'kable' and Pipe Syntax, CRAN v1.3.1 
library(visdat) # Preliminary Visualisation of Data, CRAN v0.5.3
library(parallel) # Support for Parallel computation in R, CRAN v4.0.3
library(glue) # Interpreted String Literals, CRAN v1.4.2
library(patchwork) # The Composer of Plots, CRAN v1.1.1
library(vegan) # Community Ecology Package, CRAN v2.5-7
library(phyloseq) # Handling and analysis of high-throughput microbiome census data, Bioconductor v1.32.0 
library(speedyseq) # Faster implementations of phyloseq functions, [github::mikemc/speedyseq] v0.4.0 
library(Biostrings) # Efficient manipulation of biological strings, Bioconductor v2.56.0 
library(HTSSIP) # High Throughput Sequencing of Stable Isotope Probing Data Analysis, CRAN v1.4.1 
library(DESeq2) # Differential gene expression analysis based on the negative binomial distribution, Bioconductor v1.28.1 
library(ggtree) # an R package for visualization of tree and annotation data, Bioconductor v2.2.4  # don't load here because of conflict with phyloseq
# library(IHW) # Independent Hypothesis Weighting, Bioconductor v1.20.0 
```

```{r style settings, echo=F, message=F, warning=F, results="asis", cache=T}
options(width = 90, knitr.table.format = "html") 
cache.path <- "06_Diff_abund_DESeq2_cache/"
fig.path <- "06_Diff_abund_DESeq2_figures/"
knitr::opts_chunk$set(
  warning = FALSE,
  message = FALSE,
  cache = TRUE,
  dev = "png",
  # dev = c("svglite", "png"),
  dev.args = list(png = list(bg = 'white')),
  # dev.args = list(svglite = list(bg = 'white'), png = list(bg = 'white')),
  dpi = 300,
  #  fig.width = 12,
  #  fig.height = 8,
  cache.path = cache.path,
  fig.path = fig.path
)
f_name <- "DejaVu Sans" #sub("\\s//", "", f_name)
f_size <- 12
font_import(pattern = "DejaVuSans\\.", prompt = FALSE)
loadfonts() # registers fonts
theme_set(theme_bw(base_size = f_size, base_family = f_name))
```

```{r functions, include=F}
#' gz
#' Compress a file using gz and delete the uncompressed file
#'
#' @param in_path (Required) Path and file name of a file to be compressed
#'
#' @param out_path (Required) Path and file name of the compressed file
#'
#' @author Roey Angel
#'
#' @return none
#'
#' @usage gz(paste0(file.path, ".svg"), paste0(file.path, ".svgz"))
#' @export

gz <- function(in_path, out_path = tempfile()) {
  out <- gzfile(out_path, "w")
  writeLines(readLines(in_path), out)
  close(out)

  file.remove(in_path)
  invisible(out_path)
}

#' Save a plot to svgz and png
#' The function uses `svglite` and `agg_png` devices and then comresses the svg to an svgz
#'
#' @param filename (Required) Path and file name excluding suffix (Default: "Rplot")
#'
#' @param plot (Required) Plot to save, defaults to last plot displayed
#'
#' @param scale (Optional) Multiplicative scaling factor (Default: 1)
#' 
#' @param pwidth, @param pheight (Optional) Plot size in "in" (Defaults: 10, 8)
#'
#' @param dpi (Optional) Plot resolution (Default: 300)
#'
#' @author Roey Angel
#'
#' @return none
#'
#' @usage save_figure(filename = "Rplot", 
#'                        plot = last_plot(), 
#'                        pwidth = 10, 
#'                        pheight = 8, 
#'                        dpi = 300, 
#'                        scale = 1, 
#'                        bg = "white",
#'                        pointsize = 12)
#' @export

save_figure <- function(filename = "Rplot", 
                        plot = last_plot(), 
                        pwidth = 10, 
                        pheight = 8, 
                        dpi = 300, 
                        scale = 1, 
                        bg = "white",
                        pointsize = 12) {
  require(svglite)
  require(ragg)
  
  svglite(paste0(filename, ".svg"), 
          width = pwidth, 
          height = pheight)
  print(plot)
  invisible(dev.off())
  
  agg_png(paste0(filename, ".png"),
          width = pwidth, 
          height = pheight, 
          units = "in",
          res = dpi, 
          scaling = scale)
  print(plot)
  invisible(invisible(dev.off()))
  
  gz(paste0(filename, ".svg"), paste0(filename, ".svgz"))
}

#' scale_libraries
#'
#' Scales libraries by:
#' 1) Taking proportions
#' 2) Multiplying by a given library size of n
#' 3) Rounding
#'
#' @param ps_obj (Required) A phyloseq object
#'
#' @param n (Optional) Library size to scale to (Default: min(sample_sums(physeq)))
#'
#' @param round (Optional) Rounding method. Either "floor" (default) or "round"
#'
#' @author https://github.com/DenefLab/MicrobeMiseq/blob/master/R/miseqR.R
#' @return A phyloseq objectn ordered data frame with the columns: ASV names, taxonomic rank names and abundance
#' @usage scale_libraries(Ps_obj, n = min(sample_sums(physeq)), round = "floor")
#' @export
#'
#'
scale_libraries <- function(physeq, n = min(sample_sums(physeq)), round = "floor") {
  require(phyloseq)

  # Transform counts to n
  physeq.scale <- transform_sample_counts(physeq,
    function(x) {(n * x/sum(x))}
  )

  # Pick the rounding functions
  if (round == "floor") {
    otu_table(physeq.scale) <- floor(otu_table(physeq.scale))
  } else if (round == "round") {
    otu_table(physeq.scale) <- round(otu_table(physeq.scale), digits = 0)
  }

  # Prune taxa and return new phyloseq object
  physeq.scale <- prune_taxa(taxa_sums(physeq.scale) > 0, physeq.scale)
  return(physeq.scale)
}

#' @title Replace zeros in OTU abundance
#'
#' @source <https://rdrr.io/github/vmikk/metagMisc/src/R/phyloseq_transform.R>
#' @param physeq A phyloseq-class object
#' @param method Which method to apply for zero replacement ("pseudocount")
#' @param pseudocount Constant value
#'
#' @return Phyloseq object with transformed counts in OTU table.
#' @export
#'
#' @examples
#'
phyloseq_replace_zero <- function(physeq, method = "pseudocount", pseudocount = 0.65){

  ## Extract OTU table
  tmp <- phyloseq::otu_table(physeq)

  ## Replace zeros with pseudocount
  if(method == "pseudocount"){
    tmp[ tmp == 0 ] <- pseudocount
  }

  ## Replace zeros with minimum observed OTU abundance
  if(method == "min"){
    trows <- taxa_are_rows(physeq)

    if(trows == TRUE){
      ## Find minimum non-zero abundances for each sample
      mins <- apply(X = tmp, MARGIN = 2, FUN = function(z){ z <- z[z > 0]; min(z) })

      ## Replace zeros with sample-specific count
      for(i in 1:ncol(tmp)){
        tmp[ tmp[, i] == 0, i ] <- mins[i]
      }
    }

    if(trows == FALSE){
      mins <- apply(X = tmp, MARGIN = 1, FUN = function(z){ z <- z[z > 0]; min(z) })
      for(i in 1:nrow(tmp)){
        tmp[ i, tmp[i, ] == 0 ] <- mins[i]
      }
    }
  } # end of 'min' method

  ## Replace OTU table
  phyloseq::otu_table(physeq) <- tmp
  return(physeq)
}

#' plot_lib_dist
#' Plot distribution of amplicon library sizes as a histogram
#'
#' @param Ps_obj (Required) A phyloseq object
#'
#' @author Roey Angel (https://github.com/roey-angel)
#' @return A ggplot object
#' @usage plot_lib_dist(Ps_obj)
#' @export

plot_lib_dist <- function(Ps_obj){
  require(ggplot2)
  require(scales)
  data.frame(sum = sample_sums(Ps_obj)) %>%
  ggplot(aes(x = sum)) +
    geom_histogram(color = "black",
                   fill = "indianred") +
    theme(panel.grid.minor = element_blank()) +
    labs(x = "Library size" , y = "Sample count") ->
    lib_dist_plot
  return(lib_dist_plot)
}

#' phyloseq_to_deseq2_safe
#' A wrapper for phyloseq::phyloseq_to_deseq2() but ensures that the right reference level is used
#'
#' phyloseq_to_deseq2() converts a phyloseq object to a deseq2 object. However for DESeq2 to work properly the reference level in the factor being tested needs to be the first level in the factor (R's default is alphabetical)
#'
#' @author Roey Angel (https://github.com/roey-angel)
#' @usage physeq_merge_samples(ps_obj, grouping_name = "Description")
#' @param ps (Required). A phyloseq object that has sample indices.
#'
#' @param test_condition (Required). A single character string matching a variable name in
#' the corresponding sample_data of \code{ps}.
#'
#' @param ref_level (Required). A single character string to be set as the reference level for DESeq2 (must be a factor level of test_condition)
#'
#' @return A DESeq2 object
#'
#' @seealso \code{\link{phyloseq::phyloseq_to_deseq2}}
#'
#' @export

## TODO:

phyloseq_to_deseq2_safe <- function(ps = ps_obj, test_condition = "Density.zone", ref_level = "Light") {
  require(magrittr)
  require(forcats)
  require(phyloseq)

  # critical for DESeq2 that the reference is the first level!!
  sample_data(ps)[[test_condition]] %<>% fct_relevel(., ref_level)
  expr <- as.formula(paste("~", test_condition))
  phyloseq_to_deseq2(ps, expr) %>%
    return(.)
}

mark_rare_taxa <- function(ps_obj, rank = "Phylum", rare_thresh = 0.01){
  require(dplyr)
  require(phyloseq)
  require(speedyseq)
  
  # glomerate to the "Rank" level
  ps_obj_glom <- tax_glom(ps_obj, 
                          rank, 
                          NArm = TRUE) 
  
  ps_obj_glom_rel <- transform_sample_counts(ps_obj_glom, 
                                             function(x) x / sum(x)) # transform to rel. ab.
  
  # convert to df
  ps_obj_df <- speedyseq::psmelt(ps_obj_glom_rel) # generate a df
  ps_obj_df %<>%
    mutate(Rank = as.character(!!sym(rank)))
   
  # group dataframe by Phylum, calculate sum rel. abundance
  ps_obj_df %>%
    group_by(!!sym(rank)) %>%
    summarise(Sum = sum(Abundance) / nsamples(ps_obj)) %>% 
    filter(Sum < rare_thresh) %>% # find Taxa whose mean rel. abund. is less than thresh
    pull(rank) -> 
    Rare_phyla 
  
  # change their name to "Rare"
  tax_table(ps_obj) %<>% 
    as.data.frame() %>%  
    rownames_to_column("OTU") %>% 
    mutate(across(rank, 
                  ~if_else(!!sym(rank) %in% Rare_phyla, "Rare", !!sym(rank)))) %>% 
    column_to_rownames("OTU") %>% 
    as.matrix() %>% 
    tax_table()
    return(ps_obj)
}

order_taxa <- function(ps_obj, rank = "Phylum", rel_abund = TRUE){
  require(dplyr)
  require(phyloseq)
  require(speedyseq)
  
  ps_obj %>%
    tax_glom(taxrank = rank) %>%                     # agglomerate at 'Rank' level
    {if(rel_abund) transform_sample_counts(., function(x) x / sum(x)) else .} %>% # convert to rel abundance 
    psmelt() %>%                                        # Melt to long format
    arrange(rank) %>%                                  # arrange by 'Rank'
    group_by(across(rank)) %>% 
    summarise(Abundance = sum(Abundance)) %>%
    arrange(desc(Abundance)) %>% 
    mutate(across(rank, ~factor(., levels = fct_inorder(.)))) %>%  
    mutate(across(rank, ~fct_relevel(., "Rare", after = Inf))) ->
    Taxa_order 
  
  return(Taxa_order)
}

prep_DESeq_data <- function(DESeq_results, ps_obj, sig_level = alpha_thresh, LFC = LFC_thresh, rank = "Phylum", rare_thresh = 0.01) {
  require(dplyr)
  require(magrittr)
  require(phyloseq)
  
  if (!is.list(DESeq_results)) {DESeq_results <- list(DESeq_results)} # convert to list if it is not (to support a vectorised run of DESEq2)
  
  # mark rare phyla
  ps_obj %>% mark_rare_taxa(., rank = rank, rare_thresh = rare_thresh) -> ps_obj
  
  # group dataframe by OTU, calculate median rel. abundance
  ps_obj %>%
    transform_sample_counts(., function(x) x / sum(x) * 100) %>% 
    taxa_sums(.) %>% 
    map_dbl(~(.x / nsamples(ps_obj))) %>% 
    enframe(name = "OTU", value = "Mean abundance (%)") -> 
    baseMean
  
  Taxa_order <- order_taxa(ps_obj)
  
  DESeq_results[[1]] %>% 
    as.data.frame() %>% 
    rownames_to_column(var = "OTU") %>% 
    left_join(., baseMean, by = "OTU") %>% # add mean abundance to results table
    bind_cols(., as(tax_table(ps_obj)[taxa_names(ps_obj) %in% .$OTU, ], "data.frame")) %>% # add taxnomy
    mutate(across(rank, ~factor(., levels = levels(Taxa_order$Phylum)))) %>% # order taxa by abundance
    mutate(Significance = if_else(padj < sig_level &
                            !is.na(padj) &
                            abs(lfcSE) > LFC,
                            "Pass",
                            "Fail"))  %>% 
    mutate(ymin = if_else(Significance == "Pass", log2FoldChange - lfcSE, NA_real_),
           ymax = if_else(Significance == "Pass", log2FoldChange + lfcSE, NA_real_)) -> # add error
    DESeq2plot

  return(DESeq2plot)
}

plot_DESeq <- function(DESeq_results, ps_obj, sig_level = alpha_thresh, LFC = LFC_thresh, rank = "Phylum", rare_thresh = 0.01, OTU_labels = FALSE, Y_val = "log2FoldChange", plot_title = "") {
  require(ggplot2)
  require(ggrepel)
  require(ggtext)
  
  DESeq2plot <- prep_DESeq_data(DESeq_results, ps_obj, sig_level, LFC, rank, rare_thresh)
  
  DESeq_summary <- tibble(Label = c(paste0("⬆", 
                                           sum(DESeq2plot$log2FoldChange > 0 & 
                                                 DESeq2plot$Significance == "Pass"),
                                           " (", nrow(DESeq2plot), ")")))
  
  pos <- position_jitter(width = 0.3, seed = 1)
  
  p <-
    ggplot(DESeq2plot) +
    geom_point(aes(
      x = !!sym(rank),
      y = !!sym(Y_val),
      colour = !!sym("Significance"),
      size = !!sym("Mean abundance (%)")),
      position = pos,
      alpha = 1 / 3,
      stroke = 0) +
    geom_linerange(aes(x = !!sym(rank),
                       y = !!sym(Y_val),
                       ymin = ymin,
                       ymax = ymax,
                       colour = !!sym("Significance")),
                   position = pos,
                   alpha = 1/5, 
                   show.legend = FALSE) +
    geom_text(
      data    = DESeq_summary,
      mapping = aes(x = Inf, y = Inf, label = Label),
      hjust   = 1.1,
      vjust   = 1.6
    ) +
    labs(x = "", y = "Log<sub>2</sub> fold change", title = plot_title) +
    labs(colour = paste("Significance at \n p <", sig_level), size = "Mean abundance (%)") +
    theme_grey(base_size = f_size, base_family = f_name) +
    theme(axis.text.x = element_text(angle = 45.0, vjust = 1, hjust = 1),
          panel.grid.major.x = element_blank(),
          panel.grid.minor.x = element_blank(),
          axis.title.y = element_markdown(),
          plot.title = element_markdown(size = f_size)) +
    guides(colour = guide_legend(override.aes = list(size = 5))) +
    # scale_colour_manual(values = c(ggpomological:::pomological_base[[7]], ggpomological:::pomological_palette[[1]])) +
    scale_colour_manual(values = c("#2b323f", "#c03728")) +
    scale_size_continuous(name = "Mean abundance (%)",
                          range = c(2, 8),
                          breaks = c(round(seq(min(DESeq2plot$`Mean abundance (%)`), max(DESeq2plot$`Mean abundance (%)`), length.out = 5), 1)))
  
  if (OTU_labels) {
    p <- p + geom_label_repel(
      aes(x = !!sym(rank), y = !!sym(Y_val)),
      size = 6,
      label = sub("Seq_([0-9]+)", "\\1", pull(DESeq2plot[DESeq2plot$Significance == "Pass", ], "OTU")),
      position = pos,
      data = DESeq2plot[DESeq2plot$Significance == "Pass", ],
      # nudge_x = 0.4,
      colour = "#4a4a4a",
      label.size = NA, 
      alpha = 0.75, 
      # fontface = 'bold',
      box.padding = 0.80,
      point.padding = 0.5
    )
  }
  return(p)
}

plot_otus_by_density <- function(ps_obj = Ps_obj_SIP_all_reps_l[[1]], 
                                 ASV2plot = filter(DESeq_res_SIP_each_rep_LFC_sig_df, 
                                                   Treatment == "Natural", 
                                                   Sample.no. == 1),
                                 ASV_colours = ggpomological:::pomological_palette[c(2, 4, 3, 1)],
                                 X_val = "Density..g.ml.1.", 
                                 Y_val = "Abundance", 
                                 shape_val = "Sample.no.",
                                 colour_val = "Label..18O.",
                                 topN = 30){
  require(ggpomological)
  require(dplyr)
  require(phyloseq)
  require(speedyseq)
  
  ps_obj %>% 
    transform_sample_counts(function(x) x/sum(x) * 100) %>% 
    prune_taxa(ASV2plot$ASV, .) %>% 
    prune_taxa(unique(arrange(ASV2plot, desc(log2FoldChange))$ASV)[1:topN], .) %>% 
    # prune_taxa(names(sort(taxa_sums(.), TRUE)[1:topN]), .) %>%
    psmelt() ->
    Incorporators_df
  
  ggplot(Incorporators_df, aes(x = !!sym(X_val),
                               y = !!sym(Y_val),
                               shape = as.factor(!!sym(shape_val)),
                               colour = as.factor(!!sym(colour_val)))) + 
    scale_colour_manual(values = ASV_colours) +
    # scale_colour_pomological() +
    geom_point(alpha = 1/2, size = 3) + 
    geom_line() +
    facet_wrap("OTU", scales = "free_y") +
    guides(colour = guide_legend(title = "Label"), 
           shape = guide_legend(title = "Label <sup>18</sup>O")) +
    labs(x = "Density (g ml<sup>-1</sup>)",
         title = paste(ASV2plot$Treatment[1])) +
    theme(legend.title = element_markdown(),
          axis.title.x = element_markdown(),
          plot.title = element_markdown())
  
  
}

plot_ggtree <- function(ps_obj, 
                        rank = "Phylum",
                        subrank = "Order",
                        Taxa2plot = "Actinobacteriota",
                        lab_rows = 4){
  require(magrittr)
  require(ggplot2)
  require(ggtree)
  require(RColorBrewer)
  
  # subset (phyloseq subset_taxa doesn't support quasiquotation)
  ps_obj %>% 
    tax_table() %>%
    as("data.frame") %>%
    rownames_to_column("ASV") %>% 
    filter(., !!sym(rank) == Taxa2plot) %>% 
    column_to_rownames("ASV") %>% 
    as.matrix() %>% 
    tax_table() ->
    tax_table(ps_obj)
  
  tax_table(ps_obj) %>% 
    as("data.frame") %>% 
    pull(subrank) %>% 
    unique() %>% 
    length() ->
    n_colours

  p_tree <- ggtree(ps_obj,
                       layout = "rectangular") +
    geom_tippoint(aes(colour = !!sym(subrank)), 
                  size = 2, 
                  alpha = 1/2) +
    scale_color_manual(subrank, 
                       values = colorRampPalette(brewer.pal(11, "Spectral"))(n_colours)) +
    # geom_tiplab(hjust=-.3, size = 2) +
    geom_treescale(fontsize = 2) +
    guides(colour = guide_legend(nrow = lab_rows,
                                 byrow = TRUE,
                                 title.position = "top")) +
    theme_tree(legend.title = element_markdown(size = f_size - 4),
               legend.position = "bottom", 
               legend.key.size = unit(0.1, "cm"),
               legend.text = element_markdown(size = f_size - 6),
               legend.box = "vertical", 
               legend.margin = margin(),
               plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"),
               plot.title = element_text(size = f_size - 2)) +
    # scale_colour_manual(values = mycolours) +
    ggtitle(Taxa2plot)
  return(p_tree)
}

plot_ggtree_heatmap <- function(p_ggtree, 
                                ps_obj,
                                DESeq_res_df,
                                rank = "Phylum",
                                Taxa2plot = "Actinobacteriota",
                                x = "Comparison_pair",
                                facet_names = "Treatment",
                                sample_colours = "black"){
  require(dplyr)
  require(ggplot2)
  require(viridis)
  require(ggtext)
  
  ps_obj %>% 
    tax_table() %>%
    as("data.frame") %>%
    rownames_to_column("ASV") %>% 
    filter(., !!sym(rank) == Taxa2plot) %>% 
    column_to_rownames("ASV") %>% 
    as.matrix() %>% 
    tax_table() ->
    tax_table(ps_obj)
  
  p_ggtree$data %>% 
    arrange(y, label) %>% 
    pull(label) %>% 
    unique() -> tip_order
  
  DESeq_res_df %>% 
    right_join(., tibble(ASV = taxa_names(ps_obj)), 
               by  = "ASV") ->
    DESeq_res_df_sub
  
colors <- sample_colours
labels2draw <- as.character(unique(pull(DESeq_res_df_sub, facet_names)))
labels <- setNames(glue("<i style='colors:{colors}'>{labels2draw}</i>"), labels2draw)

  DESeq_res_df_sub %>% 
    # filter(Labelled == "Labelled") %>% 
    mutate(log2FoldChange = ifelse(Labelled == "Labelled", log2FoldChange, NA_integer_)) %>% # retain values for labelled ASVs only
    select(ASV, !!sym(x), !!sym(facet_names), log2FoldChange) %>% 
    mutate(across(ASV, ~factor(., levels = tip_order))) %>%
    complete(., ASV) %>%
    ggplot(., aes(!!sym(x), ASV, fill = log2FoldChange)) + 
    geom_tile(colour = "white",
              size = 0.25) +
    # scale_fill_gradient(low = "gray", high = "darkred") +
    scale_fill_viridis(na.value = "white",
                       option = "inferno") +
    guides(fill = guide_legend(title = "Log<sub>2</sub> fold change",
                               title.position = "top")) +
    facet_wrap(vars(!!sym("Treatment")),
               labeller = as_labeller(labels),
               nrow = 1) +
    theme(axis.text.x = element_markdown(size = f_size - 6,
                                         angle = 45, 
                                         vjust = 1, 
                                         hjust = 1),
          panel.grid.major = element_blank(),
          axis.title.y = element_blank(),
          axis.title.x = element_markdown(size = f_size - 4),
          axis.text.y = element_blank(),
          axis.ticks.y = element_blank(),
          strip.background = element_blank(),
          strip.text =  element_markdown(size = f_size - 6),
          legend.key.size = unit(0.3, "cm"),
          legend.title = element_markdown(size = f_size - 4),
          legend.position = "bottom",
          legend.text = element_text(size = f_size - 6),
          plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm")) ->
    HM_plot
  
  return(HM_plot)
  
}

wrap_ggtree_heatmap <- function(ps_obj, 
                                DESeq_res_df,
                                rank = "Class",
                                subrank = "Order",
                                Taxa2plot = "Actinobacteria",
                                x = "Comparison_pair",
                                facet_names = "Treatment",
                                lab_rows = 4,
                                pwidth = 4,
                                pheight = 7){
  p_t <- plot_ggtree(ps_obj, 
                     rank = rank,
                     subrank = subrank,
                     Taxa2plot = Taxa2plot,
                     lab_rows = lab_rows)
  p_hm <- plot_ggtree_heatmap(p_ggtree = p_t, 
                              ps_obj,
                              DESeq_res_df, 
                              rank = rank,
                              Taxa2plot = Taxa2plot,
                              x = x,
                              facet_names = facet_names,
                              sample_colours = brewer.pal(n = 11, 
                                                              "RdYlGn")[c(11, 1)])
  p_t_hm <- (p_t + p_hm) + 
    plot_layout(widths = c(1, 1))
  
  save_figure(paste0(fig.path, "Tree_HM_", Taxa2plot), 
              p_t_hm, 
              pwidth = pwidth, 
              pheight = pheight,
              dpi = 600)
  
  return(p_t_hm)
}
```

## Differential abundance modelling of SIP gradients
Here we attempt to detect ASVs that were labelled with ^18^O in the soil incubations using differential abundance modelling.
Using DESeq2 [@love_moderated_2014] we compare the relative abundance of each ASV in the fractions where ^18^O-labelled DNA is expected to be found (>1.70 g ml^-1^; AKA 'heavy' fractions) in the labelled gradients to the heavy fractions in the unlabelled gradient. The method has been previously described in Angel [-@angel_stable_2019].

### Setting general parameters:
```{r general parameters, cache=T}
set.seed(2021)
alpha_thresh <- 0.1
LFC_thresh <- 0.2
samples_prep_path <- "./"
data_path <- "./DADA2_pseudo/"
Proj_name <- "Zin_SIP"
Ps_file <- paste0(Proj_name, "_filt_wTree.Rds")
Tree_file <- "./Tree/DADA2.Seqs_decontam_filtered.filtered.align.treefile"
```

### Load phyloseq object
This phyloseq object was created in [05_Taxonomical_analysis.html](05_Taxonomical_analysis.html) by including the iqtree-calculated tree.
The phyloseq object excludes contaminants, all sequences classified as eukaryota, chloroplast, mitochondria or unknown, taxa with low prevalence. 
```{r load phyloseq, cache=T}
setwd("C:/Users/Talia Gabay/OneDrive - post.bgu.ac.il/PhD/SIP experiment/Analyses/Analysis_With_Roey")
Ps_obj <- readRDS(file = paste0(data_path, Ps_file))
# Ps_obj <- phyloseq_replace_zero(Ps_obj)
```

### Beta diversity analysis
Let us look first at the dissimilarity in community composition between the different fractions. If the labelling was strong enough we should see a deviation of (some of) the heavy fractions from the light ones. However, a lack of a significant deviation does not mean unsuccessful labelling because if only a small minority of the community was labelled we might not see it here (but we will, hopefully, see it using DESeq2 modelling).

```{r beta div joint, cache=T}
(mod1 <- adonis(vegdist(otu_table(Ps_obj), method = "horn") ~ Treatment + Library.size,
  data = as(sample_data(Ps_obj), "data.frame"),
  permutations = 999
))

plot_lib_dist(Ps_obj)

Ps_obj %>%
  scale_libraries(round = "round") ->
  Ps_obj_SIP_scaled
  
plot_lib_dist(Ps_obj_SIP_scaled)

(mod2 <- adonis(vegdist(otu_table(Ps_obj_SIP_scaled), method = "horn") ~ Treatment + Library.size,
  data = as(sample_data(Ps_obj_SIP_scaled), "data.frame"),
  permutations = 999
))


(mod3 <- adonis(vegdist(otu_table(Ps_obj_SIP_scaled), method = "horn") ~ Treatment * Density.zone,
  data = as(sample_data(Ps_obj_SIP_scaled), "data.frame"),
  permutations = 999
))

Treatment_disp <- betadisper(vegdist(otu_table(Ps_obj_SIP_scaled), method = "horn"), get_variable(Ps_obj_SIP_scaled, "Treatment"))
permutest(Treatment_disp)
plot(Treatment_disp)
#Comparison_pair_disp <- betadisper(vegdist(otu_table(Ps_obj_SIP_scaled), method = "horn"), get_variable(Ps_obj_SIP_scaled, "Comparison_pair"))
#permutest(Oxygen_disp)
#plot(Oxygen_disp)
#Hours_disp <- betadisper(vegdist(otu_table(Ps_obj_SIP_scaled), method = "horn"), get_variable(Ps_obj_SIP_scaled, "Hours"))
#permutest(Hours_disp)
#plot(Hours_disp)
Density_disp <- betadisper(vegdist(otu_table(Ps_obj_SIP_scaled), method = "horn"), get_variable(Ps_obj_SIP_scaled, "Density.zone"))
permutest(Density_disp)
plot(Density_disp)
```

```{r ordinations, fig.height=12, cache=T}
Ord <- ordinate(Ps_obj_SIP_scaled, "CAP", "horn", 
                formula =  ~ Treatment * Density.zone)
explained <- as.numeric(format(round(eigenvals(Ord)/sum(eigenvals(Ord)) * 100, 1), nsmall = 1))
Ord_plt <- plot_ordination(Ps_obj, Ord, type = "samples", color = "Label..18O.", justDF = TRUE)

p_ord_joint <- ggplot(Ord_plt) +
  geom_point(aes(
               x = CAP1,
               y = CAP2,
               color = Label..18O.,
               size = Density..g.ml.1.,
               shape = Treatment
             ), alpha = 2 / 3) +
  guides(colour = guide_legend(title = "Labelling"), 
         size = guide_legend(title = "Density (g ml<sup>-1</sup>)"),
         shape = guide_legend(title = "Treatment")) +
  scale_colour_locuszoom() +
  # scale_colour_manual(values = Gradient.colours) +
  # scale_fill_manual(values = Gradient.colours, guide = "none") +
  labs(x = sprintf("CAP1 (%s%%)", explained[1]),
  y = sprintf("CAP2 (%s%%)", explained[2])) +
  coord_fixed(ratio = sqrt(explained[2] / explained[1])) +
   theme(legend.justification = "top",
         legend.title = element_markdown(size = 11)
         ) +
  scale_size_continuous(breaks = round(c(seq(min(Ord_plt$Density..g.ml.1.), 
                                       max(Ord_plt$Density..g.ml.1.), 
                                       length.out = 5), 
                                   1), 4),
                        range = c(0.1, 5)) +
  facet_grid("Treatment") +
  # ggtitle("Joint analysis") +
  NULL

save_figure(paste0(fig.path, "Oridnation"), 
            p_ord_joint, 
            pwidth = 10, 
            pheight = 8,
            dpi = 600)

knitr::include_graphics(paste0(fig.path, "Oridnation", ".png"))
```

### Subset the dataset
Because the DESeq2 models will be run on each gradient-pair separately, we need to subset This is easily done using `HTSSIP::phyloseq_subset` [@youngblut_htssip_2018]
```{r subset dataset, cache=T}
# split, ignore replicates (for labelled ASV plots)
# test_expr_1 <- "(Site == '${Site}' & Oxygen == '${Oxygen}' & Label..13C. == 'Unlabelled') | (Site == '${Site}'  & Oxygen == '${Oxygen}' & Label..13C. == '${Label..13C.}')"
# params_1 <- get_treatment_params(Ps_obj_SIP, c("Site",
#                                    "Oxygen",
#                                    "Glucose",
#                                    "Label..13C."),
#                      "Label..13C. != 'Unlabelled'")

test_expr_1 <- "Treatment == '${Treatment}'"

params_1 <- get_treatment_params(Ps_obj, c("Treatment"))

Ps_obj %>% 
  subset_samples(Density.zone == "Heavy") %>% 
  phyloseq_subset(., params_1, test_expr_1) %>% 
  lapply(.,
           function(x) {filter_taxa(x, function(y) sum(y) > 0, TRUE)}) -> # remove 0-summed ASVs
  Ps_obj_SIP_all_reps_l

names(Ps_obj_SIP_all_reps_l) %<>%
  map(., ~str_remove_all(.x, "\\s\\|\\s.*")) %>%
  map(., ~str_remove_all(.x, "\\(|\\)|Treatment == |'"))

#split, include time points (for DESeq2 modelling)
test_expr_2 <- "(Treatment == '${Treatment}' & Comparison_pair  == '${Comparison_pair}')"
params_2 <- get_treatment_params(Ps_obj, c("Treatment", 
                                   "Comparison_pair"))

# Generate a list of subsetted phyloseq objects
Ps_obj %>% 
  subset_samples(Density.zone == "Heavy") %>% 
  phyloseq_subset(., params_2, test_expr_2) %>% 
    lapply(.,
           function(x) {filter_taxa(x, function(y) sum(y) > 0, TRUE)}) -> # remove 0-summed ASVs
  Ps_obj_SIP_each_rep_l

names(Ps_obj_SIP_each_rep_l) %<>%
  map(., ~str_remove_all(.x, "\\s\\|\\s.*")) %>%
  map(., ~str_remove_all(.x, "\\(|\\)|Treatment == |Comparison_pair  == |'"))

## Get the common sequences between natural and restored active sequences (labelled)
treatment1 <- colnames(otu_table(Ps_obj_SIP_all_reps_l$Natural))
treatment2 <- colnames(otu_table(Ps_obj_SIP_all_reps_l$Restored))
shared <- intersect(treatment1, treatment2)
print(shared)
```

### Differential abundance models
Now run the differential abundance models using DESeq2. We then filter the resutls to include only ASVs with Log_2_ fold change >`LFC_thresh` and significant at P<`alpha_thresh`. Lastly, we run 'LFC-shrinking' based on Stephens [-@stephens_fdr_2016].
```{r DESeq2 models, cache=T}
# generate a DESeq2 object
DESeq_obj_SIP_each_rep_l <- lapply(Ps_obj_SIP_each_rep_l, 
                                   function(x) {phyloseq_to_deseq2_safe(x, 
                                                                        test_condition = "Label..18O.", 
                                                                        ref_level = "Unlabelled")}) 
                                  

# DESeq_obj_SIP_each_rep_zb_l <- mclapply(DESeq_obj_SIP_each_rep_l, 
#                                         function(x) {zinbwave(x,
#                                                               X="~ 1",
#                                                               epsilon = 1e10,
#                                                               verbose = TRUE,
#                                                               K = 0,
#                                                               observationalWeights = TRUE,
#                                                               BPPARAM = BiocParallel::SerialParam())},
#                                         mc.cores = nrow(params_2))

# DESeqDataSet(dds_zinbwave, design = ~ Label..18O.)


# run dds pipeline
DESeq_obj_SIP_each_rep_l %<>% lapply(., 
                                     function(x) {DESeq(x, 
                                                        test = "Wald",
                                                        # test = "LRT",
                                                        # reduced = ~1, 
                                                        fitType = "local",
                                                        sfType = "poscounts")})
                                    # run dds pipeline

map(seq(length(DESeq_obj_SIP_each_rep_l)), 
                        ~plotDispEsts(DESeq_obj_SIP_each_rep_l[[.x]]))


# extract results from a DESeq analysis
# DESeq_res_SIP_each_rep_l  <- mclapply(DESeq_obj_SIP_each_rep_l, 
#                              function(x) {
#                                results(x, 
#                                        altHypothesis = "greater",
#                                        alpha = alpha_thresh, 
#                                        # filterFun = ihw,
#                                        contrast = c("Label..18O.", "Labelled", "Unlabelled"))}, # redundant if phyloseq_to_deseq2_safe() was used but doesn't hurt
#                              mc.cores = nrow(params_2)) 

DESeq_res_SIP_each_rep_LFC_l <- lapply(DESeq_obj_SIP_each_rep_l, 
                                     function(x) {
                                       results(x,
                                               lfcThreshold = LFC_thresh,
                                               altHypothesis = "greater",
                                               alpha = alpha_thresh,
                                               # filterFun = ihw, # optional alternative to BH (package IHW)
                                               contrast = c("Label..18O.", "Labelled", "Unlabelled"))}) # redundant if phyloseq_to_deseq2_safe() was used but doesn't hurt
                                      # Extract results from a DESeq analysis


DESeq_res_SIP_each_rep_LFC_shrink_l <- map(seq(length(DESeq_obj_SIP_each_rep_l)), 
                                             ~lfcShrink(DESeq_obj_SIP_each_rep_l[[.x]],
                                                         res = DESeq_res_SIP_each_rep_LFC_l[[.x]],
                                                         coef = "Label..18O._Labelled_vs_Unlabelled",
                                                         type = "ashr"))
names(DESeq_res_SIP_each_rep_LFC_shrink_l) <- names(DESeq_res_SIP_each_rep_LFC_l)

# Compare
# plotMA(DESeq_res_SIP_each_rep_l[[2]], ylim = c(-2,2))
plotMA(DESeq_res_SIP_each_rep_LFC_l[[1]])
plotMA(DESeq_res_SIP_each_rep_LFC_shrink_l[[1]])



# summarise results (lfcShrink doesn't change the values)
for (i in seq(1, length(DESeq_res_SIP_each_rep_LFC_l))) { # didn't manage with map
  print(names(DESeq_res_SIP_each_rep_LFC_l[i]))
  summary(DESeq_res_SIP_each_rep_LFC_l[[i]])
}

DESeq_res_SIP_each_rep_LFC_shrink_l %>% 
  map(., ~subset(.x, padj < alpha_thresh & log2FoldChange > LFC_thresh)) %>% 
  map(., ~as.data.frame(.x)) %>% 
  map(., ~rownames_to_column(.x, "ASV")) %>% 
  bind_rows(., .id = "Comparison") %>% 
  arrange(Comparison, desc(baseMean))  %>% 
  separate(., "Comparison" ,c("Treatment","Comparison_pair"), sep = " & ") %T>% 
  write_csv(., file = paste0("DESeq2_each_rep_a-", alpha_thresh, "_LFC0-", LFC_thresh, ".txt")) ->
  DESeq_res_SIP_each_rep_LFC_sig_df
```

#### Inspect results
```{r vis DES res, cache=T}
DESeq_res_SIP_each_rep_LFC_sig_df %>% 
  get_variable() %>% 
  select_if(is.numeric) %>% 
  vis_value()

DESeq_res_SIP_each_rep_LFC_sig_df %>% 
  get_variable() %>% 
  select_if(is.numeric) %>% 
  vis_cor()
```

#### Plot differential abundance models
```{r plot DESeq2 models, fig.height=14, fig.width=12, cache=T}
# ps_obj <- Ps_obj
# DESeq_results <- DESeq_res_SIP_byTime_LFC0.322_l[9]
# plot_DESeq(DESeq_results, ps_obj, plot_title = names(DESeq_results))

DESeq_plots <- map(seq(length(DESeq_res_SIP_each_rep_LFC_shrink_l)), 
                        ~plot_DESeq(DESeq_res_SIP_each_rep_LFC_shrink_l[.x],  
                                                Ps_obj, plot_title = names(DESeq_res_SIP_each_rep_LFC_shrink_l[.x])))

Natural_DESeq2 <- ((DESeq_plots[[1]] + 
                     theme(legend.position = "none") +
                     theme(axis.text.x = element_blank())) +
                    (DESeq_plots[[2]] + 
                       theme(legend.position = "none", 
                             axis.text.x = element_blank(), 
                             axis.title.y = element_blank())) +
                    (DESeq_plots[[3]] + 
                       theme(legend.position = "none",
                             axis.text.x = element_blank())) +
                    (DESeq_plots[[4]] + 
                       theme(legend.position = "none", 
                             axis.text.x = element_blank(), 
                             axis.title.y = element_blank())) +
                    (DESeq_plots[[5]]) + 
                    plot_layout(ncol = 2, guides = "collect") & 
                    theme(legend.position = 'bottom'))

save_figure(paste0(fig.path, "Natural_DESeq2"), 
            Natural_DESeq2, 
            pwidth = 14, 
            pheight = 12,
            dpi = 600)

knitr::include_graphics(paste0(fig.path, "Natural_DESeq2", ".png"))

Restored_DESeq2 <- ((DESeq_plots[[6]] + 
                     theme(legend.position = "none") +
                     theme(axis.text.x = element_blank())) +
                    (DESeq_plots[[7]] + 
                       theme(legend.position = "none", 
                             axis.text.x = element_blank(), 
                             axis.title.y = element_blank())) +
                    (DESeq_plots[[8]] + 
                       theme(legend.position = "none",
                             axis.text.x = element_blank())) +
                    (DESeq_plots[[9]] + 
                       theme(legend.position = "none", 
                             axis.text.x = element_blank(), 
                             axis.title.y = element_blank())) +
                    (DESeq_plots[[10]] + 
                       theme(legend.position = "none", 
                             axis.title.y = element_blank())) + 
                    plot_layout(ncol = 2, guides = "collect") & 
                    theme(legend.position = 'bottom'))

save_figure(paste0(fig.path, "Restored_DESeq2"), 
            Restored_DESeq2, 
            pwidth = 14, 
            pheight = 12,
            dpi = 600)

knitr::include_graphics(paste0(fig.path, "Restored_DESeq2", ".png"))
```

### Plot labelled ASVs
```{r plot labelled ASVs, fig.height=12, fig.width=16, cache=T}
plot_combintions <- crossing(Treatment = c("Natural", "Restored"))

Labelled_ASVs <- map(seq(length(Ps_obj_SIP_all_reps_l)), ~plot_otus_by_density(Ps_obj_SIP_all_reps_l[[.x]], 
                     ASV2plot = filter(DESeq_res_SIP_each_rep_LFC_sig_df, Treatment == plot_combintions$Treatment[.x])))

map(seq(length(Ps_obj_SIP_all_reps_l)), 
    ~save_figure(paste0(fig.path, "Labelled_ASVs_", paste(plot_combintions[.x, ], collapse = "_")), 
                 Labelled_ASVs[[.x]], 
                 pwidth = 16, 
                 pheight = 12,
                 dpi = 600))

plots2display <- list.files(path = paste0(fig.path), 
                    pattern = "^Labelled_ASVs_(.*).png$",
                    full.names = TRUE)

knitr::include_graphics(plots2display)
```

#### Plot phylogenetic trees with heatmaps
```{r Plot trees, fig.height=8, fig.width=10, cache=T}
c("Natural", "Restored")  ->
  col_order

DESeq_res_SIP_each_rep_LFC_shrink_l %>% 
  map(., ~as.data.frame(.x)) %>% 
  map(., ~rownames_to_column(.x, "ASV")) %>% 
  bind_rows(., .id = "Comparison") %>% 
  # filter(str_detect(Comparison, "Labelled")) %>% # remove unlabelled samples [c(-5, -10, -15, -20)]
  mutate(Labelled = ifelse(padj < alpha_thresh & log2FoldChange > LFC_thresh, "Labelled", "Unlabelled")) %>% 
  # arrange(Comparison, desc(baseMean)) %>% 
  separate(., "Comparison" ,c("Treatment","Comparison_pair"), sep = " & ") %>% 
  mutate(Treatment_pair = paste(Treatment, Comparison_pair)) %>% 
  mutate(across(Treatment_pair, ~as.factor(.))) %>% 
  # mutate(Site_Oxygen = factor(paste0(Site, "-", Oxygen),
  #                             levels = c("Plesne-Oxic", "Plesne-Anoxic", "Certovo-Oxic", "Certovo-Anoxic"),
  #                             labels = c("Pl-Ox", "Pl-Anox", "Ct-Ox", "Ct-Anox"))) %>%
  # mutate(across(c("Hours"), ~factor(., 
  #                                   levels = c("12 h", "24 h", "48 h", "72 h", "216 h"),
  #                                   labels = c("12", "24", "48", "72", "216")))) 
  identity() ->
  # mutate(Site_oxygen = paste(Site, Oxygen)) ->
  DESeq_res_SIP_each_rep_df

# Summarise number of labelled and unlabelled ASVs
DESeq_res_SIP_each_rep_df %>% 
  group_by(Labelled) %>% 
  summarise(n = n()) 

# detect taxa with NA from DESeq analysis
DESeq_res_SIP_each_rep_df %<>% 
  filter(!is.na(Labelled)) #%>% 
  # pull(Labelled) -> 
  # bad_seqs

# remove NA taxa from PS obj
Ps_obj %>% 
  # prune_taxa(setdiff(taxa_names(Ps_obj), "Seq_2375"), .) %>% # outlier
  prune_taxa(DESeq_res_SIP_each_rep_df$ASV, .) ->
  Ps_obj_SIP4tree_plot


# Remove long name
tax_table(Ps_obj_SIP4tree_plot)[, "Order"] %<>%  str_replace_all(., "Gammaproteobacteria Incertae Sedis", "Incertae Sedis")


taxa2plot <- tibble(rank = c(rep("Class", 3), rep("Phylum", 4)), 
                    subrank = c(rep("Order", 3), rep("Class", 4)), 
                    Taxa2plot = c("Actinobacteria", 
                                  "Alphaproteobacteria", 
                                  "Gammaproteobacteria", 
                                  "Gemmatimonadota",
                                  "Cyanobacteria",
                                  "Bacteroidota",
                                  "Firmicutes"),
                    # lab_rows = c(4, 5, 6, 3, 3, 3, 3),
                    # pwidth = c(5, 6, 8, 3, 3, 3, 3), 
                    # pheight = c(rep(10, 7)),)
                    lab_rows = c(rep(4, 7)),
                    pwidth = c(rep(5, 7)), 
                    pheight = c(rep(8, 7)),)

tree_p_l <- map(seq(nrow(taxa2plot)), 
                ~wrap_ggtree_heatmap(ps_obj = Ps_obj_SIP4tree_plot,
                                     DESeq_res_df = DESeq_res_SIP_each_rep_df,
                                     rank = taxa2plot$rank[.x],
                                     subrank = taxa2plot$subrank[.x],
                                     Taxa2plot = taxa2plot$Taxa2plot[.x],
                                     lab_rows = 4,
                                     pwidth = 5,
                                     pheight = 8))

trees2display <- list.files(path = paste0(fig.path), 
                    pattern = "^Tree_HM_(.*).png$",
                    full.names = TRUE)

knitr::include_graphics(trees2display)

all_trees <- ((tree_p_l[[1]] | tree_p_l[[2]] + guides(fill = FALSE) | tree_p_l[[3]] + guides(fill = FALSE) | tree_p_l[[6]] + guides(fill = FALSE)) / (tree_p_l[[4]] + guides(fill = FALSE) | tree_p_l[[5]] + guides(fill = FALSE) | tree_p_l[[7]] + guides(fill = FALSE) | plot_spacer())) + plot_layout(heights = c(2, 1))

save_figure(paste0(fig.path, "all_trees"), 
            all_trees, 
            pwidth = 18, 
            pheight = 20,
            dpi = 900)
#original version - save_figure(paste0(fig.path, "all_trees"), 
            #all_trees, 
            #pwidth = 16, 
            #pheight = 18,
            #dpi = 900)
```

```{r colophon, eval=T}
sessioninfo::session_info() %>%
  details::details(
    summary = 'Current session info',
    open    = TRUE
 )
```

## References
